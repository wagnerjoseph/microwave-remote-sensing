[
  {
    "objectID": "unit_02/old_06_backscatter-variability.html",
    "href": "unit_02/old_06_backscatter-variability.html",
    "title": "Load Sentinel-1 data",
    "section": "",
    "text": "import os\nimport xarray as xr\nimport rioxarray\nimport rasterio\nimport dask.array as da\nfrom glob import glob\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport folium\nimport matplotlib.patches as patches\nfrom datetime import datetime\nimport pandas as pd\nLoad Metadata to get some information on the data. We want to get the scale_factor of the data.\ndata_path = Path('~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler').expanduser() # SAT-1 data is inside the saocom_gamma folder but this could change\ntif_files = glob(f\"{data_path}/*.tif\")\n\nfor tif_path in tif_files:\n    print(f\"Metadata for file: {os.path.basename(tif_path)}\")\n    with rasterio.open(tif_path) as src:\n      tags = src.tags()\n      print(src.meta)\n      print(f\"Tags: {tags}\")\n      print(f\"Scalefactor: {tags.get('scale_factor')}\\n\")\n      #break\n    \n\nMetadata for file: D20230922_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050443', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_7_A01_gmr_jobfile_A0105_log_20231201_082733.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230922T165124_20230922T165149_050443_06130C_7915.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 08:27:33', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-09-22 16:51:24', 'time_end': '2023-09-22 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230829_165123--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050093', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_073256.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230829T165123_20230829T165148_050093_060726_855E.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 07:32:57', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-29 16:51:23', 'time_end': '2023-08-29 16:51:48', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230817_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '049918', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_065607.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230817T165122_20230817T165147_049918_060121_784A.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 06:56:08', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-17 16:51:22', 'time_end': '2023-08-17 16:51:47', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231016_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050793', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_14_A01_gmr_jobfile_A0105_log_20231201_051314.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231016T165124_20231016T165149_050793_061F17_EF2F.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 05:13:15', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-16 16:51:24', 'time_end': '2023-10-16 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230805_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '049743', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_034630.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230805T165122_20230805T165147_049743_05FB3C_64DB.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 03:46:31', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-05 16:51:22', 'time_end': '2023-08-05 16:51:47', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231004_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050618', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_13_A01_gmr_jobfile_A0105_log_20231201_035056.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231004T165124_20231004T165149_050618_06190F_38E7.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 03:50:57', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-04 16:51:24', 'time_end': '2023-10-04 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230910_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050268', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_4_A01_gmr_jobfile_A0105_log_20231201_080609.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230910T165124_20230910T165149_050268_060D16_BAC4.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 08:06:10', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-09-10 16:51:24', 'time_end': '2023-09-10 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231028_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050968', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_13_A01_gmr_jobfile_A0105_log_20231201_020603.xml', 'orbit_aux_file': 'None', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231028T165124_20231028T165149_050968_062503_8D6A.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'False', 'processing_date': '2023-12-01 02:06:04', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-28 16:51:24', 'time_end': '2023-10-28 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\nAs we can see frome here the data was captured 8 images between the 5th August 2023 and the 28th October 2023. The image contains Gamma VV values.\nNow we can load the data and and apply preprocessing. From the Metaddata we could extract a scalingfactor of 100 which we now need to apply.\nWe get a xarray.DataSet and convert it to an xarray.DataArray because we only have one variable, the VV backscatter.\nWe have 8 timestemps. For performance reasons we will fous on only on one time becasue the data does not change to much over time.\n(Using DataArray is slower than DataSet)\ndef _preprocess(x):  \n    scale_factor = pd.to_numeric(\n        rasterio.open(x.encoding[\"source\"]).tags().get('scale_factor')\n    )\n\n    time_value = pd.to_datetime(\n        rasterio.open(x.encoding[\"source\"]).tags().get('time_begin')\n    )\n\n    x = x / scale_factor\n\n    x = x.assign_coords(time=time_value).expand_dims(\"time\")\n\n    return x.squeeze(\"band\").drop_vars(\"band\")\n\nds = xr.open_mfdataset(\n    '~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler/*.tif',\n    engine=\"rasterio\",\n    combine='nested',\n    concat_dim=\"time\",\n    preprocess=_preprocess\n)\n\nds = ds[list(ds.data_vars.keys())[0]] .isel(time=1)\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 10000, x: 10000)&gt; Size: 800MB\ndask.array&lt;getitem, shape=(10000, 10000), dtype=float64, chunksize=(1, 10000), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 80kB 5.2e+06 5.2e+06 5.2e+06 ... 5.3e+06 5.3e+06\n  * y            (y) float64 80kB 1.6e+06 1.6e+06 1.6e+06 ... 1.5e+06 1.5e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 10000x: 10000dask.array&lt;chunksize=(1, 10000), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n762.94 MiB\n78.12 kiB\n\n\nShape\n(10000, 10000)\n(1, 10000)\n\n\nDask graph\n10000 chunks in 42 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           10000 10000\n\n\n\n\nCoordinates: (4)x(x)float645.2e+06 5.2e+06 ... 5.3e+06 5.3e+06array([5200005., 5200015., 5200025., ..., 5299975., 5299985., 5299995.])y(y)float641.6e+06 1.6e+06 ... 1.5e+06 1.5e+06array([1599995., 1599985., 1599975., ..., 1500025., 1500015., 1500005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5200005.0, 5200015.0, 5200025.0, 5200035.0, 5200045.0, 5200055.0,\n       5200065.0, 5200075.0, 5200085.0, 5200095.0,\n       ...\n       5299905.0, 5299915.0, 5299925.0, 5299935.0, 5299945.0, 5299955.0,\n       5299965.0, 5299975.0, 5299985.0, 5299995.0],\n      dtype='float64', name='x', length=10000))yPandasIndexPandasIndex(Index([1599995.0, 1599985.0, 1599975.0, 1599965.0, 1599955.0, 1599945.0,\n       1599935.0, 1599925.0, 1599915.0, 1599905.0,\n       ...\n       1500095.0, 1500085.0, 1500075.0, 1500065.0, 1500055.0, 1500045.0,\n       1500035.0, 1500025.0, 1500015.0, 1500005.0],\n      dtype='float64', name='y', length=10000))Attributes: (0)\nds_downscaled = ds.coarsen(x=100, y=100, boundary='pad').mean()\nds_downscaled\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 100, x: 100)&gt; Size: 80kB\ndask.array&lt;mean_agg-aggregate, shape=(100, 100), dtype=float64, chunksize=(1, 100), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 800B 5.2e+06 5.202e+06 ... 5.298e+06 5.3e+06\n  * y            (y) float64 800B 1.6e+06 1.598e+06 ... 1.502e+06 1.5e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 100x: 100dask.array&lt;chunksize=(1, 100), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n78.12 kiB\n800 B\n\n\nShape\n(100, 100)\n(1, 100)\n\n\nDask graph\n100 chunks in 51 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           100 100\n\n\n\n\nCoordinates: (4)x(x)float645.2e+06 5.202e+06 ... 5.3e+06array([5200500., 5201500., 5202500., 5203500., 5204500., 5205500., 5206500.,\n       5207500., 5208500., 5209500., 5210500., 5211500., 5212500., 5213500.,\n       5214500., 5215500., 5216500., 5217500., 5218500., 5219500., 5220500.,\n       5221500., 5222500., 5223500., 5224500., 5225500., 5226500., 5227500.,\n       5228500., 5229500., 5230500., 5231500., 5232500., 5233500., 5234500.,\n       5235500., 5236500., 5237500., 5238500., 5239500., 5240500., 5241500.,\n       5242500., 5243500., 5244500., 5245500., 5246500., 5247500., 5248500.,\n       5249500., 5250500., 5251500., 5252500., 5253500., 5254500., 5255500.,\n       5256500., 5257500., 5258500., 5259500., 5260500., 5261500., 5262500.,\n       5263500., 5264500., 5265500., 5266500., 5267500., 5268500., 5269500.,\n       5270500., 5271500., 5272500., 5273500., 5274500., 5275500., 5276500.,\n       5277500., 5278500., 5279500., 5280500., 5281500., 5282500., 5283500.,\n       5284500., 5285500., 5286500., 5287500., 5288500., 5289500., 5290500.,\n       5291500., 5292500., 5293500., 5294500., 5295500., 5296500., 5297500.,\n       5298500., 5299500.])y(y)float641.6e+06 1.598e+06 ... 1.5e+06array([1599500., 1598500., 1597500., 1596500., 1595500., 1594500., 1593500.,\n       1592500., 1591500., 1590500., 1589500., 1588500., 1587500., 1586500.,\n       1585500., 1584500., 1583500., 1582500., 1581500., 1580500., 1579500.,\n       1578500., 1577500., 1576500., 1575500., 1574500., 1573500., 1572500.,\n       1571500., 1570500., 1569500., 1568500., 1567500., 1566500., 1565500.,\n       1564500., 1563500., 1562500., 1561500., 1560500., 1559500., 1558500.,\n       1557500., 1556500., 1555500., 1554500., 1553500., 1552500., 1551500.,\n       1550500., 1549500., 1548500., 1547500., 1546500., 1545500., 1544500.,\n       1543500., 1542500., 1541500., 1540500., 1539500., 1538500., 1537500.,\n       1536500., 1535500., 1534500., 1533500., 1532500., 1531500., 1530500.,\n       1529500., 1528500., 1527500., 1526500., 1525500., 1524500., 1523500.,\n       1522500., 1521500., 1520500., 1519500., 1518500., 1517500., 1516500.,\n       1515500., 1514500., 1513500., 1512500., 1511500., 1510500., 1509500.,\n       1508500., 1507500., 1506500., 1505500., 1504500., 1503500., 1502500.,\n       1501500., 1500500.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5200500.0, 5201500.0, 5202500.0, 5203500.0, 5204500.0, 5205500.0,\n       5206500.0, 5207500.0, 5208500.0, 5209500.0, 5210500.0, 5211500.0,\n       5212500.0, 5213500.0, 5214500.0, 5215500.0, 5216500.0, 5217500.0,\n       5218500.0, 5219500.0, 5220500.0, 5221500.0, 5222500.0, 5223500.0,\n       5224500.0, 5225500.0, 5226500.0, 5227500.0, 5228500.0, 5229500.0,\n       5230500.0, 5231500.0, 5232500.0, 5233500.0, 5234500.0, 5235500.0,\n       5236500.0, 5237500.0, 5238500.0, 5239500.0, 5240500.0, 5241500.0,\n       5242500.0, 5243500.0, 5244500.0, 5245500.0, 5246500.0, 5247500.0,\n       5248500.0, 5249500.0, 5250500.0, 5251500.0, 5252500.0, 5253500.0,\n       5254500.0, 5255500.0, 5256500.0, 5257500.0, 5258500.0, 5259500.0,\n       5260500.0, 5261500.0, 5262500.0, 5263500.0, 5264500.0, 5265500.0,\n       5266500.0, 5267500.0, 5268500.0, 5269500.0, 5270500.0, 5271500.0,\n       5272500.0, 5273500.0, 5274500.0, 5275500.0, 5276500.0, 5277500.0,\n       5278500.0, 5279500.0, 5280500.0, 5281500.0, 5282500.0, 5283500.0,\n       5284500.0, 5285500.0, 5286500.0, 5287500.0, 5288500.0, 5289500.0,\n       5290500.0, 5291500.0, 5292500.0, 5293500.0, 5294500.0, 5295500.0,\n       5296500.0, 5297500.0, 5298500.0, 5299500.0],\n      dtype='float64', name='x'))yPandasIndexPandasIndex(Index([1599500.0, 1598500.0, 1597500.0, 1596500.0, 1595500.0, 1594500.0,\n       1593500.0, 1592500.0, 1591500.0, 1590500.0, 1589500.0, 1588500.0,\n       1587500.0, 1586500.0, 1585500.0, 1584500.0, 1583500.0, 1582500.0,\n       1581500.0, 1580500.0, 1579500.0, 1578500.0, 1577500.0, 1576500.0,\n       1575500.0, 1574500.0, 1573500.0, 1572500.0, 1571500.0, 1570500.0,\n       1569500.0, 1568500.0, 1567500.0, 1566500.0, 1565500.0, 1564500.0,\n       1563500.0, 1562500.0, 1561500.0, 1560500.0, 1559500.0, 1558500.0,\n       1557500.0, 1556500.0, 1555500.0, 1554500.0, 1553500.0, 1552500.0,\n       1551500.0, 1550500.0, 1549500.0, 1548500.0, 1547500.0, 1546500.0,\n       1545500.0, 1544500.0, 1543500.0, 1542500.0, 1541500.0, 1540500.0,\n       1539500.0, 1538500.0, 1537500.0, 1536500.0, 1535500.0, 1534500.0,\n       1533500.0, 1532500.0, 1531500.0, 1530500.0, 1529500.0, 1528500.0,\n       1527500.0, 1526500.0, 1525500.0, 1524500.0, 1523500.0, 1522500.0,\n       1521500.0, 1520500.0, 1519500.0, 1518500.0, 1517500.0, 1516500.0,\n       1515500.0, 1514500.0, 1513500.0, 1512500.0, 1511500.0, 1510500.0,\n       1509500.0, 1508500.0, 1507500.0, 1506500.0, 1505500.0, 1504500.0,\n       1503500.0, 1502500.0, 1501500.0, 1500500.0],\n      dtype='float64', name='y'))Attributes: (0)\nTo get an idea of the region we are looking at we want to display it. Therefore we combine 100 pixles to a single one using the mean to get faster printing performance.\nareas = [\n    {'name': 'area1', 'x_min': 5.21e+06, 'x_max': 5.22e+06, 'y_min': 1.56e+06, 'y_max': 1.57e+06},\n    {'name': 'area2', 'x_min': 5.285e+06, 'x_max': 5.295e+06, 'y_min': 1.56e+06, 'y_max': 1.57e+06},\n    #{'name': 'area3', 'x_min': 528500, 'x_max': 529500, 'y_min': 156000, 'y_max': 156000}\n    ]\n\nfig, ax = plt.subplots(figsize=(15, 10))\n\nds_downscaled.plot(ax=ax, robust=True)\n\nfor area in areas:\n    rect = patches.Rectangle(\n        (area['x_min'], area['y_min']),\n        area['x_max'] - area['x_min'],\n        area['y_max'] - area['y_min'],\n        linewidth=2,\n        edgecolor='red',\n        facecolor='none'\n    )\n    ax.add_patch(rect)\nax.set_aspect('equal')\n\nplt.show()\nWe will now focus on a smaller red region to make the runtime faster. We combing the time dimensions by using the mean.\narea_dataarrays = {}\n\nfor area in areas:\n    roi = ds_WGS84.sel(\n        x=slice(area['lon_min'], area['lon_max']),\n        y=slice(area['lat_max'], area['lat_min'])\n    )\n    roi_mean = roi.mean(dim='time')\n    area_dataarrays[area['name']] = roi_mean\n\nds_area1 = area_dataarrays['area1']\nds_area2 = area_dataarrays['area2']\nds_area3 = area_dataarrays['area3']\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 4\n      1 area_dataarrays = {}\n      3 for area in areas:\n----&gt; 4     roi = ds_WGS84.sel(\n      5         x=slice(area['lon_min'], area['lon_max']),\n      6         y=slice(area['lat_max'], area['lat_min'])\n      7     )\n      8     roi_mean = roi.mean(dim='time')\n      9     area_dataarrays[area['name']] = roi_mean\n\nNameError: name 'ds_WGS84' is not defined\nfig, ax  = plt.subplots(1,3, figsize=(24,6))\n\nds_area1.plot(ax=ax[0], robust=True)\nds_area2.plot(ax=ax[1], robust=True)\nds_area3.plot(ax=ax[2], robust=True)"
  },
  {
    "objectID": "unit_02/old_06_backscatter-variability.html#load-corine-land-cover",
    "href": "unit_02/old_06_backscatter-variability.html#load-corine-land-cover",
    "title": "Load Sentinel-1 data",
    "section": "Load Corine Land cover",
    "text": "Load Corine Land cover"
  },
  {
    "objectID": "unit_02/old_06_backscatter-variability.html#select-vv-and-vh",
    "href": "unit_02/old_06_backscatter-variability.html#select-vv-and-vh",
    "title": "Load Sentinel-1 data",
    "section": "Select VV and VH",
    "text": "Select VV and VH"
  },
  {
    "objectID": "unit_02/old_06_backscatter-variability.html#plotting-a-histogram",
    "href": "unit_02/old_06_backscatter-variability.html#plotting-a-histogram",
    "title": "Load Sentinel-1 data",
    "section": "Plotting a histogram",
    "text": "Plotting a histogram"
  },
  {
    "objectID": "unit_02/old_06_backscatter-variability.html#plotting-in-the-epsg27704",
    "href": "unit_02/old_06_backscatter-variability.html#plotting-in-the-epsg27704",
    "title": "Load Sentinel-1 data",
    "section": "Plotting in the EPSG:27704",
    "text": "Plotting in the EPSG:27704\nIn the EPSG:27704 coordinate system (plotting is quite slow):\n\nds_downsampled = ds.isel().coarsen(x=10, y=10, boundary='pad').mean()\n\n\ndata_vars = list(ds.data_vars)\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Plot each variable (image) in the dataset\nfor var in data_vars:\n    img = ds_downsampled[var]\n    img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n\nplt.show()"
  },
  {
    "objectID": "unit_02/old_06_backscatter-variability.html#get-the-overlapping-area",
    "href": "unit_02/old_06_backscatter-variability.html#get-the-overlapping-area",
    "title": "Load Sentinel-1 data",
    "section": "Get the overlapping area",
    "text": "Get the overlapping area\n\ndata_vars = list(ds_WGS84.data_vars)\n\nds_overlapping = ds_WGS84[data_vars[0]]  # Start with the first variable\n\nfor var in data_vars[1:]:\n    next_image = ds_WGS84[var]\n    ds_overlapping = ds_overlapping.rio.clip_box(*next_image.rio.bounds())\n\nTo reduce the runtime we downsample the data to make the plotting faster.\n\nds_downsampled = ds_WGS84.isel().coarsen(x=10, y=10, boundary='pad').mean()\nds_overlapping_downsampled = ds_overlapping.isel().coarsen(x=10, y=10, boundary='pad').mean()\n\n\nds_downsampled[data_vars[0]].plot()\n\n\nds_overlapping_downsampled.plot()\n\nWe transform our Data to the EPSG:4326 coordinate system which uses Latitude and Longitude values.\n\nds_WGS84 = ds.rio.reproject(\"EPSG:4326\")\nds_WGS84\n\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Plot each variable (image) in the dataset\nfor var in data_vars:\n    img = ds_downsampled[var]\n    img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n\n# Highlight the overlapping area with a colored box\nminx, miny, maxx, maxy = ds_overlapping_downsampled.rio.bounds()\n\n# Add a colored box for the overlapping area\nrect = plt.Rectangle((minx, miny), maxx - minx, maxy - miny, fill=False, edgecolor='red', linewidth=2)\nax.add_patch(rect)\n\n# Set labels and titles\nax.set_title(\"Overlapping Area of Satellite Images\")\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\n\nplt.show()\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[22], line 6\n      4 for var in data_vars:\n      5     img = ds_downsampled[var]\n----&gt; 6     img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n      8 # Highlight the overlapping area with a colored box\n      9 minx, miny, maxx, maxy = ds_overlapping_downsampled.rio.bounds()\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/plot/accessor.py:48, in DataArrayPlotAccessor.__call__(self, **kwargs)\n     46 @functools.wraps(dataarray_plot.plot, assigned=(\"__doc__\", \"__annotations__\"))\n     47 def __call__(self, **kwargs) -&gt; Any:\n---&gt; 48     return dataarray_plot.plot(self._da, **kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/plot/dataarray_plot.py:270, in plot(darray, row, col, col_wrap, ax, hue, subplot_kws, **kwargs)\n    219 def plot(\n    220     darray: DataArray,\n    221     *,\n   (...)\n    228     **kwargs: Any,\n    229 ) -&gt; Any:\n    230     \"\"\"\n    231     Default plot of DataArray using :py:mod:`matplotlib:matplotlib.pyplot`.\n    232 \n   (...)\n    266     xarray.DataArray.squeeze\n    267     \"\"\"\n    268     darray = darray.squeeze(\n    269         d for d, s in darray.sizes.items() if s == 1 and d not in (row, col, hue)\n--&gt; 270     ).compute()\n    272     plot_dims = set(darray.dims)\n    273     plot_dims.discard(row)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataarray.py:1194, in DataArray.compute(self, **kwargs)\n   1169 \"\"\"Manually trigger loading of this array's data from disk or a\n   1170 remote source into memory and return a new array.\n   1171 \n   (...)\n   1191 dask.compute\n   1192 \"\"\"\n   1193 new = self.copy(deep=False)\n-&gt; 1194 return new.load(**kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataarray.py:1162, in DataArray.load(self, **kwargs)\n   1142 def load(self, **kwargs) -&gt; Self:\n   1143     \"\"\"Manually trigger loading of this array's data from disk or a\n   1144     remote source into memory and return this array.\n   1145 \n   (...)\n   1160     dask.compute\n   1161     \"\"\"\n-&gt; 1162     ds = self._to_temp_dataset().load(**kwargs)\n   1163     new = self._from_temp_dataset(ds)\n   1164     self._variable = new._variable\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataset.py:865, in Dataset.load(self, **kwargs)\n    862 chunkmanager = get_chunked_array_type(*lazy_data.values())\n    864 # evaluate all the chunked arrays simultaneously\n--&gt; 865 evaluated_data: tuple[np.ndarray[Any, Any], ...] = chunkmanager.compute(\n    866     *lazy_data.values(), **kwargs\n    867 )\n    869 for k, data in zip(lazy_data, evaluated_data):\n    870     self.variables[k].data = data\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/namedarray/daskmanager.py:86, in DaskManager.compute(self, *data, **kwargs)\n     81 def compute(\n     82     self, *data: Any, **kwargs: Any\n     83 ) -&gt; tuple[np.ndarray[Any, _DType_co], ...]:\n     84     from dask.array import compute\n---&gt; 86     return compute(*data, **kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/dask/base.py:664, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)\n    661     postcomputes.append(x.__dask_postcompute__())\n    663 with shorten_traceback():\n--&gt; 664     results = schedule(dsk, keys, **kwargs)\n    666 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/queue.py:171, in Queue.get(self, block, timeout)\n    169 elif timeout is None:\n    170     while not self._qsize():\n--&gt; 171         self.not_empty.wait()\n    172 elif timeout &lt; 0:\n    173     raise ValueError(\"'timeout' must be a non-negative number\")\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/threading.py:320, in Condition.wait(self, timeout)\n    318 try:    # restore state no matter what (e.g., KeyboardInterrupt)\n    319     if timeout is None:\n--&gt; 320         waiter.acquire()\n    321         gotit = True\n    322     else:\n\nKeyboardInterrupt: \n\n\n\n\n\n\n\n\n\n\n\nds_downsampled = ds_WGS84.isel().coarsen(x=100, y=100, boundary='pad').mean()\n\nds_downsampled.plot.scatter()\n\n#plt.figure(figsize=(12, 8))\n#downsampled_data.plot(cmap='viridis')\n#plt.title('Resampled Data Slice at Time = 0')\n#plt.show()\n\n\nNormalizing Histogram approaches\n\n# rangexy approach https://holoviews.org/reference/streams/bokeh/RangeXY.html\n\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\nrenderer = hv.renderer('bokeh')\n\n\n# xarray to holoviews dataset\nhv_ds = hv.Dataset(fs.sig0.isel(time=0))\nimg = hv_ds.to(hv.Image, [\"x\", \"y\"])\nimg.opts(aspect=\"equal\", cmap=\"viridis\", colorbar=True, height=400, tools=[\"hover\"])\n\ndef selected_hist(x_range, y_range):\n\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    \n    return hvop.histogram(obj)\n\nrangexy = hv.streams.RangeXY(source=img)\n\nimg &lt;&lt; hv.DynamicMap(selected_hist, streams=[rangexy])\n\n\n# mandelbrot approach https://holoviews.org/gallery/apps/bokeh/mandelbrot.html\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\nfrom holoviews.streams import RangeXY\nfrom holoviews import opts\n\nimg = hv_ds.to(hv.Image, [\"x\", \"y\"])\nhv_ds = hv.Dataset(fs.sig0.isel(time=0))\n\ndef create_image(x_range, y_range):\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    return hv.Image(obj).opts(aspect=\"equal\", cmap=\"viridis\", colorbar=True, height=400, tools=[\"hover\"])                     \n\nrangexy = RangeXY()\n\ndmap = hv.DynamicMap(create_image, streams=[rangexy]).hist(normed=True)\n\ndmap.opts(\n    opts.Histogram(framewise=True),\n    opts.Image())\n\n\n# old\nimport holoviews as hv\nimport hvplot.xarray\nimport panel as pn\nimport xarray as xr\n\nhv.extension('bokeh')\n\nfs=fs.compute()\n\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\nmin_value = fs.sig0.min().item()\nmax_value = fs.sig0.max().item()\n\ntime_values = fs.time.values\n\nsig0_holomap = hv.HoloMap({\n    time: hv.Layout([\n        fs.sig0.sel(time=time).hvplot.image(\n            x=\"x\", y=\"y\", clim=(robust_min, robust_max), aspect=\"equal\", framewise=False\n        ).opts(cmap=\"viridis\", colorbar=True, tools=[\"hover\"],height=400, width=700),\n        fs.sig0.sel(time=time).hvplot.hist(\n            y='sig0', bins=50, bin_range=(min_value, max_value), normed=True\n        ).opts(xlabel=\"Backscatter Value\", ylabel=\"Density\",height=200, width=700)\n    ]).cols(1)\n    for time in time_values\n})\n\npn.panel(sig0_holomap).servable()"
  },
  {
    "objectID": "unit_01/02_unit-conversions.html",
    "href": "unit_01/02_unit-conversions.html",
    "title": "Unit Conversion",
    "section": "",
    "text": "In this notebook we are gonna have a look at the conversion of units. The Sentinel-1 data that is mostly used in this exercise is SAR data, which is measured in decibels (dB). In order to make meaningful calculations with the data, we need to convert the data to linear scale. Lets start with importing some libraries.\n# Imports\nimport numpy as np\nimport pystac_client\nimport odc.stac\nimport matplotlib.pyplot as plt\nfrom odc.geo.geobox import GeoBox\nfrom dask.diagnostics import ProgressBar\nfrom rasterio.crs import CRS\nimport seaborn as sns"
  },
  {
    "objectID": "unit_01/02_unit-conversions.html#backscattering-coefficients",
    "href": "unit_01/02_unit-conversions.html#backscattering-coefficients",
    "title": "Unit Conversion",
    "section": "Backscattering Coefficients",
    "text": "Backscattering Coefficients\nLets have a quick look at the different backscattering coefficients that are used in SAR data processing: - radar brightness or beta nought \\(\\beta^0\\): Is the original backscatter value related to the measurement geometry (range and azimuth). Thus, it is a quantity being independent from terrain variations (and hence also incidence angles). - sigma nought \\(\\sigma^0\\): Is the backscatter value related to the illuminated ground-area. It takes the influence of terrain variations causing a variation in illumination into account, by scaling \\(\\beta^0\\) with \\(sin(\\theta_i)\\), where \\(\\theta_i\\) is the local incidence angle. - gamma nought \\(\\gamma^0\\): Is the backscatter value related to the area perpendicular to the looking direction. It can be computed by normalising/scaling \\(\\beta^0\\) with \\(1/tan(\\theta_i)\\)"
  },
  {
    "objectID": "unit_01/02_unit-conversions.html#scale",
    "href": "unit_01/02_unit-conversions.html#scale",
    "title": "Unit Conversion",
    "section": "Scale",
    "text": "Scale\nThe decibel (dB) is a logarithmic unit used to express the ratio of two values of a physical quantity, often power or intensity. In the case of SAR data, the backscatter coefficient is often expressed in dB. The reason for that will be explained in the following example."
  },
  {
    "objectID": "unit_01/02_unit-conversions.html#mathematical-operation",
    "href": "unit_01/02_unit-conversions.html#mathematical-operation",
    "title": "Unit Conversion",
    "section": "Mathematical operation",
    "text": "Mathematical operation\nIn order to convert the data from dB to linear scale, we need to convert the data using the following formula. Let \\(x\\) be the original value (dB) and \\(y\\) the converted value (\\(m^2m^{-2}\\)). The conversion of units can be expressed as: \\[\nD =  10  \\cdot \\log_{10} (I) = 10 \\cdot \\log_{10} (e) \\cdot \\ln (I)\\longrightarrow [dB]\n\\] Similarly, the conversion back to the original unit can be expressed as: \\[\nI = e^{\\frac{D}{10\\cdot \\log_{10}(e)}} = 10^{\\frac{D}{10}} \\longrightarrow [m^2m^{-2}]  \n\\] You can find these formulas in the script for Microwave Remote Sensing on page 136 (equation 6.40).\nNow lets implement the conversion in Python.\n\n# Conversion functions\ndef lin2db(val:float|int) -&gt; float:\n    '''\n    Converts value from linear to dB units.\n\n    Parameters\n    ----------\n    x : number\n        Value in linear units.\n\n    Returns\n    -------\n    float\n        Value in dB.\n    '''\n    return 10 * np.log10(val)\n\ndef db2lin(val:float|int) -&gt; float:\n    '''\n    Converts value from dB to linear units.\n\n    Parameters\n    ----------\n    x : number\n        Value in dB.\n\n    Returns\n    -------\n    float\n        Value in linear units.\n    '''\n    return 10 ** (val / 10)\n\nThe reason why we convert the data to linear scale is that when values in dB are added or subtracted, the actual values are multiplied or divided. This is not the case when the values are in linear scale. Lets have a look at an example, where we add two values in once without the conversion to linear scale and once with the conversion to linear scale.\n\n# Logarithmic addition\n# Values in linear and decibel units\nval1_db, val2_db = 10, 12\n\n# Logarithmic addition\nsum_db = val1_db + val2_db\nprint(f'Logarithmic Addition:')\nprint(f'Logarithmic values: \\t{val1_db:&lt;5}, {val2_db:&lt;5} [dB]')\nprint(f'Logarithmic sum: \\t{val1_db} + {val2_db} = {sum_db:&lt;5}')\n\n# Linear addition\nval1_lin, val2_lin = db2lin(val1_db), db2lin(val2_db)\nsum_lin = val1_lin + val2_lin\nprint(f'\\nLinear Addition:')\nprint(f'Linear values: \\t\\t{val1_lin:&lt;5}, {val2_lin:&lt;5.2f} [lin] (converted from dB)')\nprint(f'Linear sum: \\t\\t{val1_lin} + {val2_lin:.2f} = {sum_lin:.2f} [lin]')\nprint(f'\\t\\t\\t= {lin2db(sum_lin):.2f} [dB]')\n\nprint(f'\\nValues compared in dB: \\t{sum_db} [dB] != {lin2db(sum_lin):.2f} [dB] (difference = {sum_db - lin2db(sum_lin):.2f} [dB])')\nprint(f'Values compared in lin: {db2lin(sum_db):.2f} [lin] != {sum_lin:.2f} [lin] (factor = {db2lin(sum_db) / sum_lin:.2f})')\n\nAs you can see the values in dB and in linear scale differ quite a bit. In the example above the values differ by a factor of around 6 when looked at in linear scale. This is why it is important to convert the data to linear scale before doing any calculations. Lets load some sample data and see what the difference is between the two scales and why we use dB in the first place."
  },
  {
    "objectID": "unit_01/02_unit-conversions.html#example-usage",
    "href": "unit_01/02_unit-conversions.html#example-usage",
    "title": "Unit Conversion",
    "section": "Example Usage",
    "text": "Example Usage\n\nLoad some sample data\nIn order to demonstrate why this conversion is important, we will have a look at some SAR data.\n\n# Search for some data\n\nepsg = CRS.from_epsg(4326) # WGS 84 (only integer would also work)\ndx = 0.0002 # degrees\n\n# Set Spatial extent\nlatmin, latmax = 48, 48.5\nlonmin, lonmax = 16, 17\nbounds = (lonmin, latmin, lonmax, latmax)\nminx, miny, maxx, maxy = bounds\ngeom = {\n    'type': 'Polygon',\n    'coordinates': [[\n       [minx, miny],\n       [minx, maxy],\n       [maxx, maxy],\n       [maxx, miny],\n       [minx, miny]\n    ]]\n}\n\n# Set Temporal extent\ntime_range = \"2022-08-01/2022-08-05\" # closed range\n\n# Search for Sentinel-2 data\nitems = pystac_client.Client.open(\"https://stac.eodc.eu/api/v1\").search(\n    # intersects=geom,\n    bbox=bounds,\n    collections=[\"SENTINEL1_SIG0_20M\"],\n    datetime=time_range,\n    limit=100,\n).item_collection()\n\nprint(len(items), 'scenes found')\n\n\n# Load the data into a Dask array\n\n# define a geobox for my region\ngeobox = GeoBox.from_bbox(bounds, crs=epsg, resolution=dx)\n\n# lazily combine items\nsig0_dc = odc.stac.stac_load(\n    items,\n    #bbox=bounds,\n    bands=[\"VV\", \"VH\"],\n    chunks={'time': 5, 'x': 600, 'y': 600},\n    epsg=epsg,\n    geobox=geobox,\n    resampling=\"bilinear\",\n)\n\n\n# Define the nodata value and scale factor\nnodata = -9999  # Sentinel-1 nodata value as defined by EODC\nscale = 0.1     # Sentinel-1 scale factor as defined by EODC\n\n# Preprocess the data\ntemp_mean = (sig0_dc.where(sig0_dc != nodata)*scale).VV.median(dim='time')\n\n\naoi = temp_mean.sel(latitude=slice(48.3, 48.2), longitude=slice(16.4, 16.6))\ndB_data = aoi.values.flatten()\nlin_data = db2lin(dB_data)\n\nfig, ax = plt.subplots(2,2, figsize=(10,8))\n#upper left\naoi.plot.imshow(robust=True, ax=ax[0,0])\nax[0,0].set_title('Sentinel-1 backscatter $\\sigma_0$ [$dB$]')\n\n#upper right\nsns.violinplot(data=dB_data, ax=ax[0,1])\nax[0,1].set_ylabel('$\\sigma_0$ [$dB$]')\nax[0,1].set_title('Sentinel-1  $\\sigma_0$ [$dB$] distribution')\n\n#lower left\ndb2lin(aoi).plot.imshow(robust=True, ax=ax[1,0])\nax[1,0].set_title('Sentinel-1 backscatter $\\sigma_0$ [$m^2 \\cdot m^{-2}$]')\n\n\n#lower right\nsns.violinplot(data=lin_data, ax=ax[1,1])\nax[1,1].set_ylabel('$\\sigma_0$ [$m^2 \\cdot m^{-2}$]')\nax[1,1].set_title('Sentinel-1 $\\sigma_0$ [$m^2 \\cdot m^{-2}$] distribution')\nplt.tight_layout()\n\nIn the plot above you can see the difference between the two scales. The values in dB are more evenly distributed and are therefore easier to plot. The values in linear scale are more spread out and are therefore harder to interpret. This is why we use the dB scale for plotting and the linear scale for calculations.\nNow that we have some data, we will try to calculate the average \\(\\sigma_0\\) value across the scene. We will do this by converting the data to linear scale, calculating the average and converting it back to dB.\n\n# Lets take a data array with db values\ndb_array = temp_mean.compute()\n\n# Compute the linear values\nlin_array = db2lin(db_array)\n\n\n# Compute the average backscatter value in linear units across the whole scene\nlin_mean = lin_array.mean()\nprint(f\"Average backscatter value in linear units: {lin_mean.values:.3f}\")\ndb_from_lin_mean = lin2db(lin_mean)\nprint(f\"That value in dB: {db_from_lin_mean.values:.3f}\\n\")\n\n# Compute the average backscatter value in dB across the whole scene\ndb_mean = db_array.mean()\nprint(f\"Average backscatter value in dB: {db_mean.values:.3f}\")\n\nAs you can see in the example the mean values across the scene are different in dB and linear scale. This is why it is important to convert the data to linear scale before doing any calculations. It is usually not meaningful to perform calculations on data in dB. Instead, it is better to convert the data to linear scale, perform the calculations and convert it back to dB."
  },
  {
    "objectID": "unit_01/01_discover-and-read.html",
    "href": "unit_01/01_discover-and-read.html",
    "title": "Discover Sentinel 1 data using the EODC STAC catalog",
    "section": "",
    "text": "This notebook demonstrates how to access radar data in a STAC Catalogue using the pystac library. In this examples we use here Sentinel-1 data on the EODC stac catalog. In the further process we will learn how to query a STAC catalog, select specific items and display their metadata.\nimport pystac_client\nimport folium\nfrom odc import stac as odc_stac\neodc_catalog = pystac_client.Client.open(\n    \"https://stac.eodc.eu/api/v1\"\n)\n\neodc_catalog\nEach catalog, composed by different providers, has many collections. To get all collections of a catalog, we can print all of them and their ids, which are used to fetch them from the catalog.\ncollections = eodc_catalog.get_collections()\n\nmax_length = max(len(collection.id) for collection in collections) #length of string of collection.id, for pretty print\n\nfor collection in eodc_catalog.get_collections():\n    print(f\"{collection.id.ljust(max_length)} : {collection.title}\")\nTo get a specific collection from the catalog, we can use the client.get_collection() method and provide the collection name. We can then display its description, id, temporal and spatial extend, licence, etc.\ncolllection_id = 'SENTINEL1_SIG0_20M'\n\ncollection = eodc_catalog.get_collection(colllection_id)\ncollection\nEach collection has multiple items. An item is one spatio-temporal instance the collection, for instance a satellite image. If items are needed for a specific timeframe or for a specific region of interest, we can define this as a query.\n#TODO: could you provide here more examples for instanc for a specific day only, etc.\n#time_range = \"2022-01-01/..\" # up to current date, an open range\ntime_range = \"2022-10-01/2022-10-07\" # closed range\nA spatial region of interest can be defined in different ways. One option is to define a simple bounding box:\nTo make the code cleaner, the following bounding box could be used, but generally any area of the world can be selected as polygon (does not have to be a rectangle) with geojson.io and interescts.\nlatmin, latmax = 46.3, 49.3 # South to North\nlonmin, lonmax = 13.8, 17.8 # West to East\n\nbounding_box = [lonmin, latmin, lonmax, latmax]\nIf the region of interest is not rectengular, we can also define a polygon:\n# GEOJSON can be created on geojson.io\n# This specific area of interest is a rectangle, but since it is closed polygon it seems like it has five nodes\narea_of_interest = {\n  \"coordinates\": [\n          [\n            [\n              17.710928010825853,\n              49.257630084442496\n            ],\n            [\n              13.881798300915221,\n              49.257630084442496\n            ],\n            [\n              13.881798300915221,\n              46.34747715326259\n            ],\n            [\n              17.710928010825853,\n              46.34747715326259\n            ],\n            [\n              17.710928010825853,\n              49.257630084442496\n            ]\n          ]\n        ],\n        \"type\": \"Polygon\"\n      }\nUsing our previously loaded STAC catalog, we can now search for items fullfilling our query. In this example we are using the bounding box. If we want to use an area of interest specified in the geojson format - one hast to use the intersects parameter as documented in the comment below.\nsearch = eodc_catalog.search(\n    collections=colllection_id, # can also be a list of several collections\n    bbox=bounding_box, # search by bounding box\n    #intersects=area_of_interest, # GeoJSON search\n    datetime=time_range,\n    # max_items = 1 # number of max items to load, if commented it will load all of them\n)\n\nitems_eodc = search.item_collection()\nprint(f\"On EODC we found {len(items_eodc)} items for the given search query\")\nNow, we can fetch a single item, in this case a Sentinel-1 image, from the query results. A good practice is to always check what metadata the data provider has stored on the item level.\nitems_eodc[0]\nLets display only VV polarisation of the item and some information about the data.\nitems_eodc[0].assets['VV'].extra_fields.get('raster:bands')[0]\nIn the EODC STAC catalogue an item can conveniently be displayed using its thumbnail.\nitems_eodc[0].assets['thumbnail'].href\nHere is a way to quickly check how the data found by a search query looks on a map.\nmap = folium.Map(location=[(latmin+latmax)/2, (lonmin+lonmax)/2], zoom_start=7,\n                                  zoom_control=False,\n                                  scrollWheelZoom=False,\n                                  dragging= False)\n\nfolium.GeoJson(area_of_interest, name=\"Area of Interest\").add_to(map)\n\nfor item in items_eodc:\n    image_url = item.assets['thumbnail'].href # url leading to display of an item, can also be used as hyperlink\n    bounds = item.bbox\n    folium.raster_layers.ImageOverlay(\n        image=image_url,\n        bounds=[[bounds[1], bounds[0]], [bounds[3], bounds[2]]], # bounds of item\n        ).add_to(map)\n\nfolium.LayerControl().add_to(map)\n\nmap"
  },
  {
    "objectID": "unit_01/01_discover-and-read.html#data-reading",
    "href": "unit_01/01_discover-and-read.html#data-reading",
    "title": "Discover Sentinel 1 data using the EODC STAC catalog",
    "section": "Data Reading",
    "text": "Data Reading\nSTAC can also be a useful tool for the discovery of data, however it only loads metadata. This saves memory, but if one would like to do further analysis the data has to be loaded into memory or downloaded on disk.\nThe library we use here for loading the data is called odc-stac.\n\nbands = (\"VV\", \"VH\")\ncrs = \"EPSG:4326\" # Coordinate Reference System - World Geodetic System 1984 (WGS84) in this case \nres = 0.00018 # 20 meter in degree\n\nsig0_ds = odc_stac.load(items_eodc,\n                        bands=bands,\n                        crs=crs,\n                        chunks={'time':5}, # this is size of DataArray chunk, how much time instances are loaded at once\n                        resolution=res,\n                        bbox=bounding_box,\n                        )\n\nLets display for example the VV band of the dataset.\n\nsig0_ds.VV\n\nIn this case, the displayed data is lazily loaded. This means the structure of the DataArray is constructed, but data is not loaded yet. It is loaded only at instance when it is needed, for example for plotting or computing.\n#TODO: I would not mention dask here cause we dont need it in the following notebooks. Instead I would mention that the stac load function returns an xarray dataset and breifly explain in two sentences xarray and provide a link to the read the docs. #TODO: Could we use here directly the item from the line items_eodc[0] by assigning it to a variable? This would make selecting a subset obsolet and maybe simplify the notebook. Dask library then constructs graphs with order of operations that plotting will be done, so that is the way to handle large datasets. In this example, we have 31 time instances, or 31 items.\nNevertheless, it is better to choose smaller area.\n\nlatmin_smaller, latmax_smaller = 48, 48.4\nlonmin_smaller, lonmax_smaller = 16, 16.5\n\nsmaller_bounding_box = [[latmin_smaller, lonmin_smaller],\n                        [latmax_smaller, lonmax_smaller]]\n\nmap = folium.Map(location=[(latmin_smaller+latmax_smaller)/2, (lonmin_smaller+lonmax_smaller)/2], zoom_start=8,\n                 zoom_control=False,\n                 scrollWheelZoom=False,\n                 dragging= False)\n\nfolium.GeoJson(area_of_interest, name=\"Area of Interest\").add_to(map)\n\nfolium.Rectangle(\n    bounds=smaller_bounding_box,\n    color=\"red\",\n).add_to(map)\n\nfor item in items_eodc:\n    image_url = item.assets['thumbnail'].href\n    bounds = item.bbox\n    folium.raster_layers.ImageOverlay(\n        image=image_url,\n        bounds=[[bounds[1], bounds[0]], [bounds[3], bounds[2]]],\n        ).add_to(map)\n\nfolium.LayerControl().add_to(map)\n\nmap\n\n\nsig0_ds = odc_stac.load(items_eodc,\n                        bands=bands,\n                        crs=crs,\n                        chunks={'time':5},\n                        resolution=res,\n                        bbox=[lonmin_smaller, latmin_smaller, lonmax_smaller, latmax_smaller],\n                        #groupby='time'\n                        )\n\nsig0_ds.VV\n\nNow dataset is considerably smaller. Lets plot first time instance.\n\nsig0_ds.VV.isel(time=0).plot()\n\nDue to the way the data is acquired and stored, some items include no data areas. In our case, no data has the value -9999, but this can very from data provider to data provider. This information can usually be found in the metadata. Furthermore, to save the memory, data is often stored as integer (e.g.25) and not at float (e.g.2.5) format. For this reason, the backscatter values are often multiplied by a scale factor, in this case the factor 10.\n#TODO: I would also move this to the second unit and visualize here only a single item.\nAs Sentinel-1 satellites overpasses Austria every few days and does acquisition of backscatter for few minutes, only some part of dataset will have physical data. So it is better to take daily averages (average scene that Sentinel observed for few minutes of overpass) and to see how it looks over whole week (that was previously defined in STAC search).\nNote: cell belows will take some time to run.\n\nscale = items_eodc[0].assets['VV'].extra_fields.get('raster:bands')[0]['scale'] # raster:bands is STAC raster extension\nnodata = items_eodc[0].assets['VV'].extra_fields.get('raster:bands')[0]['nodata']\n\n#TODO: Resampling should be done in the linear domain, which is only introduced in the second exercise. To keep this exercise also a bit shorter, please remove/move the part below. \nsig0_ds = sig0_ds.where(sig0_ds != nodata) / scale\n\ndaily_averages = sig0_ds.resample(time='1D').mean()\ndaily_averages.VV.plot(col='time', col_wrap=4, robust=True)\n\nTo see a bit better how scene looked over one day:\n\ndaily_averages.VV[0].plot(robust=True) # robust argument does not display outliers"
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html",
    "href": "unit_01/03_backscatter-coefficients.html",
    "title": "Normalizing Radar Cross Sections",
    "section": "",
    "text": "Microwave remote sensing is a technique that uses a certain type of electromagnetic waves (i.e., microwaves have a wavelength ranging from about one meter to one millimeter) to gather information about objects or areas on the ground. How does this work? Lets break it down into points:\nRadar imaging systems can be expressed as a ratio between scattered power (\\(P_s\\)) and incident power (\\(P_i\\)), so that:\n\\[\\sigma = \\frac{P_s}{Pi} 4 \\pi R^2 \\, [m^2] \\quad \\text{,} \\quad  \\text{(equation 1)}\\]\nprovides a backscatter coefficient for distributed targets per given reference area, also known as a radar scattering cross section.\nIncreasing the target area on ground surfaces increases the total backscattered power by the same factor, and so the radar cross sections changes with the size of illuminated area. Radar cross sections are therefore often normalized by an approximation of the illuminated ground area \\(\\hat{A}\\), as follows:.\n\\[\\sigma^0 = \\sigma /  \\hat{A} \\, [1] \\quad \\text{.} \\quad  \\text{(equation 2)}\\]\nThis correction gives a more faithful description total backscattered power independent of the size of the illuminated area.\nBackscattering can, furthermore, be highly dependent on the angle of the incident energy when the target area is signified by reflective objects of different heights, such as trees. This phenomenon is called volume scattering and can be accounted for by again normalizing with the cosine of the local incidence angle:\n\\[\\gamma^0 = \\sigma^0 / \\cos{\\theta_i} \\, [1] \\quad \\text{.} \\quad  \\text{(equation 3)} \\]\nNow lets have a look at some backscatter coefficients (\\(\\gamma^0\\) = gmr, \\(\\sigma^0\\) = sig0) and their respective local incidence angle (plia) over an area around the city of Modena, Italy."
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html#loading-normalized-backscatter-data",
    "href": "unit_01/03_backscatter-coefficients.html#loading-normalized-backscatter-data",
    "title": "Normalizing Radar Cross Sections",
    "section": "Loading Normalized Backscatter Data",
    "text": "Loading Normalized Backscatter Data\nWe first load the data with xarray, select an area of interest (AOI), and modify the variables gmr, sig0, and plia by dividing by 100. The latter step is necessary as the variables have been multiplied by 100, allowing more efficient storage of the data by decreasing the file size.\n\nimport xarray as xr\nimport rioxarray\nfrom pathlib import Path\nimport folium\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef _preprocess(x):\n    x = x / 100\n    return x.rename(\n        {\"band_data\": Path(x.encoding[\"source\"]).parent.stem}\n    ).squeeze(\"band\").drop_vars(\"band\")\n\nds = xr.open_mfdataset(\n    \"~/shared/datasets/rs/sentinel-1/A0105/EQUI7_EU010M/E047N012T1/**/*.tif\", \n    engine=\"rasterio\", \n    combine='nested', \n    preprocess=_preprocess\n    )\nds"
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html#area-of-interest",
    "href": "unit_01/03_backscatter-coefficients.html#area-of-interest",
    "title": "Normalizing Radar Cross Sections",
    "section": "Area of Interest",
    "text": "Area of Interest\nLets have a closer look at the area of interest by taking the bounding box of the xarray Dataset with rioxarray method transform_bounds and using this to define the viewing window on a leaflet map with folium.\n\nds_aoi = ds.sel(x=slice(4.78e6, 4.795e6), y=slice(1.28e6, 1.265e6)).compute()\n\nbbox = ds_aoi.rio.transform_bounds(\"EPSG:4326\")\n\nfolium.Map(\n    max_bounds=True,\n    location=[bbox[1] + (bbox[3] - bbox[1]) / 2, bbox[0] + (bbox[2] - bbox[0]) / 2],\n    min_lat=bbox[1],\n    max_lat=bbox[3],\n    min_lon=bbox[0],\n    max_lon=bbox[2],\n    zoom_control=False,\n    scrollWheelZoom=False,\n    dragging= False\n)\n\nFigure1: Map of the target area."
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html#visualizing-the-backscatter-coefficients",
    "href": "unit_01/03_backscatter-coefficients.html#visualizing-the-backscatter-coefficients",
    "title": "Normalizing Radar Cross Sections",
    "section": "Visualizing the Backscatter Coefficients",
    "text": "Visualizing the Backscatter Coefficients\nNow we can visualize the backscatter coefficients by using the xarray method plot, and by plotting these on a matplotlib figure with 2 axes (i.e., representing the subplots on a multipanel figure).\n\nfig, ax  = plt.subplots(1,2, figsize=(20,8))\n\nds_aoi.sig0.plot(ax=ax[0], robust=True)\nds_aoi.gmr.plot(ax=ax[1], robust=True)\n\nFigure 2: The \\(\\sigma^o\\) (left) and \\(\\gamma^o\\) (right) from the JupyterHub shared folder plotted on a 2D map\nNow lets have a look at how the local incidence angles look like when plotted on 2D map and compare it with \\(\\sigma^o\\).\n\nfig, ax  = plt.subplots(1,2, figsize=(20,8))\n\nds_aoi.sig0.plot(ax=ax[0], robust=True)\nds_aoi.plia.plot(ax=ax[1], robust=True)\n\nFigure 3: The \\(\\sigma^o\\) (left) and local incidence angle (plia: right) from the JupyterHub shared folder plotted on a 2D map"
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html#calculating-gammao-with-numpy",
    "href": "unit_01/03_backscatter-coefficients.html#calculating-gammao-with-numpy",
    "title": "Normalizing Radar Cross Sections",
    "section": "Calculating \\(\\gamma^o\\) with numpy",
    "text": "Calculating \\(\\gamma^o\\) with numpy\nIt is clear by looking at the local incidence angles that the area is marked by topographically severe terrain. One of the data treatments corrected for the features related to rough terrain in Figure 1, whereas the other did not.\nLets now look at what the choice of backscatter coefficient (\\(\\sigma^0\\) or \\(\\gamma^0\\)) has on the data. We do this by first converting \\(\\sigma^0\\) to \\(\\gamma^0\\) with equation 3, like so:\n\n# linear scale\nds_lin = 10 ** (ds_aoi.sig0 / 10)\n# conversion to gamma\nds_gm = ds_lin / np.cos(np.radians(ds_aoi.plia))\n# dB scale\nds_aoi[\"gm\"] = 10 * np.log(ds_gm) \n\nfig, ax  = plt.subplots(1,2, figsize=(20,8))\n\nds_aoi.sig0.plot(ax=ax[0], robust=True)\nds_aoi.gm.plot(ax=ax[1], robust=True)\n\nFigure 4: The \\(\\sigma^o\\) (left) from the JupyterHub shared folder and the derived \\(\\gamma^0\\) plotted on a 2D map"
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients.html#references",
    "href": "unit_01/03_backscatter-coefficients.html#references",
    "title": "Normalizing Radar Cross Sections",
    "section": "References",
    "text": "References\nWoodhouse, Ian H., 2006, Introduction to Microwave Remote Sensing, Chapter 5: Microwaves in the Real World, pp 93149, CRS Press"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "JupyterHub Guide",
    "section": "",
    "text": "This is a short guide to create and run the notbooks and environments in the JupiterHub for the Master course Microwave Remote Sensing (120.030) at the TU Wien."
  },
  {
    "objectID": "index.html#starting-jupyterhub",
    "href": "index.html#starting-jupyterhub",
    "title": "JupyterHub Guide",
    "section": "Starting JupyterHub",
    "text": "Starting JupyterHub\nIn TUWEL, click on the JupyterHub icon , which redirects you to your own JupyterLab user environment. You should then select the Server for the Desktop Notebook from the Microwave Remote Sensing course. Be patient - this can take a couple of minutes.\n\n\n\nPlease note that all screenshots in this guide refer to the lecture 120.030 Microwave Remote Sensing (2024W), even if a few things are different for you, the overall functionality and interface remain the same."
  },
  {
    "objectID": "index.html#exploring-jupyterlab",
    "href": "index.html#exploring-jupyterlab",
    "title": "JupyterHub Guide",
    "section": "Exploring JupyterLab",
    "text": "Exploring JupyterLab\nWhen you start your server for the first time, your point of entry will be this starting page:\n\n\n\nIn the center, you have the Launcher where you can create Python or other files, play around with Jupyter Notebooks, store intermediate data. You can also open a Python console, a terminal, a text file, and many more. On the left, you can see your home directory where you have the folders lectures and shared. There might be other folders as well, but dont be concerned about them.\n\n\nAfter some intense coding and analysis, it can happen that you have many terminal and notebook tabs open. However, simply closing them does not quit the processes and running kernels in the background. Therefore, we recommend that you tidy up your running processes after some time, which can be done as marked by the top-left circle. As an overview, the number of running kernels and terminals are always shown at the bottom-left corner."
  },
  {
    "objectID": "index.html#setup-of-exercise-environment",
    "href": "index.html#setup-of-exercise-environment",
    "title": "JupyterHub Guide",
    "section": "Setup of Exercise Environment",
    "text": "Setup of Exercise Environment\nTo use the Notebooks from the course, the following steps need to be taken:\n\nNavigate to the folder ~/shared/120.030-2024W/where you should find a Makefile and a README.md.\n\n\n\n\n\nIn this file, you should open a Terminal using the Launcher and run the command\nmake notebooks\nWait until the installation is finished - this can take a couple of minutes.\nThe notebooks and an environment, where the important packages and all their dependencies are included, have been installed for you.\nIt might be necessary to re-login to the JupyterHub to see it coming into effect.\nNow you should see a file named microwave-remote-sensing containing the notebooks and additional kernels in the Launcher of JupyterLab.\n\n\n\n\n\nSelect the kernel with the equivalent name as the .ipynb notebook to execute the notebook. For example, 01_lecture.ipynb requires the kernel 01_lecture for execution of the code blocks.\n\n\n\n\n\n\n\n\n\n\n\nIn case you could not select the correct server and could not find the folder from step one, you might be in the wrong server. You can change your server by selecting\nFile -&gt; Hub Control Panel\nand clicking on Stop My Server.\n\n\n\nThen press Start My Server and you should be able to select the Deeplearning Notebook for the Data Science Projects in Remote Sensing course."
  },
  {
    "objectID": "unit_01/03_backscatter-coefficients_exercise.html",
    "href": "unit_01/03_backscatter-coefficients_exercise.html",
    "title": "Template Notebook for TUW JupyterHub",
    "section": "",
    "text": "Calculate the absolute difference between \\(\\gamma^0\\) and \\(\\sigma^0\\) on a linear scale:\n\\[ A = \\gamma^0 - \\sigma^0 \\, [1] \\quad \\text{,}  \\]\nand the ratio on the Decibel range of \\(\\gamma^0\\) relative to \\(\\sigma^0\\), like so:\n\\[ R = \\frac{\\gamma^0}{\\sigma^0} \\, [dB] \\quad \\text{.} \\]\nWe can do these conversions by component wise mathematical operations with standard math operators on the xarray. Remember the rules of logarithms when performing these operations!\nUse the following Python modules and data for the calculations.\n\nimport xarray as xr\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom pathlib import Path\n\n\ndef _preprocess(x):\n    x = x * 0.01\n    return x.rename(\n        {\"band_data\": Path(x.encoding[\"source\"]).parent.stem}\n    ).squeeze(\"band\").drop_vars(\"band\")\n\nds = xr.open_mfdataset(\n    \"~/shared/datasets/rs/sentinel-1/A0105/EQUI7_EU010M/E047N012T1/**/*.tif\", \n    engine=\"rasterio\", \n    combine='nested', \n    preprocess=_preprocess\n    )\nds_aoi = ds.sel(x=slice(4.78e6, 4.795e6), y=slice(1.28e6, 1.265e6)).compute()\nds_aoi\n\n\nA = ...\n\n\nA.plot(robust=True, cmap=\"viridis\")\n\n\nR = ...\n\n\nR.plot(robust=True, cmap=\"viridis\")"
  },
  {
    "objectID": "unit_01/02_unit-conversions_exercise.html",
    "href": "unit_01/02_unit-conversions_exercise.html",
    "title": "Unit conversion exercise",
    "section": "",
    "text": "Find at least two different areas of interest (max extent of 1), where you would expect significatly different backscatter values (Desert, forest, water, urban area, etc.). For each area of interest, compute the mean backscatter value across the area in dB for a time frame in summer and one in winter. Compare the results.\nSome functions have already been implemented for you. Fill out all the missing parts indicated by ... or # YOUR CODE HERE. You may adapt the code as you see fit. The final plot should show the average backscatter values for the different areas of interest in summer and winter and it should include the differences that occure when the mean across the scene is calculated with linear values or with logarithmic values.\n\n# Imports\nimport numpy as np\nimport pystac_client\nimport odc.stac\nimport matplotlib.pyplot as plt\nfrom odc.geo.geobox import GeoBox\nfrom dask.diagnostics import ProgressBar\nfrom rasterio.crs import CRS\nimport seaborn as sns\nimport pandas as pd"
  },
  {
    "objectID": "unit_01/02_unit-conversions_exercise.html#problem-statement",
    "href": "unit_01/02_unit-conversions_exercise.html#problem-statement",
    "title": "Unit conversion exercise",
    "section": "",
    "text": "Find at least two different areas of interest (max extent of 1), where you would expect significatly different backscatter values (Desert, forest, water, urban area, etc.). For each area of interest, compute the mean backscatter value across the area in dB for a time frame in summer and one in winter. Compare the results.\nSome functions have already been implemented for you. Fill out all the missing parts indicated by ... or # YOUR CODE HERE. You may adapt the code as you see fit. The final plot should show the average backscatter values for the different areas of interest in summer and winter and it should include the differences that occure when the mean across the scene is calculated with linear values or with logarithmic values.\n\n# Imports\nimport numpy as np\nimport pystac_client\nimport odc.stac\nimport matplotlib.pyplot as plt\nfrom odc.geo.geobox import GeoBox\nfrom dask.diagnostics import ProgressBar\nfrom rasterio.crs import CRS\nimport seaborn as sns\nimport pandas as pd"
  },
  {
    "objectID": "unit_01/02_unit-conversions_exercise.html#conversion-formulas",
    "href": "unit_01/02_unit-conversions_exercise.html#conversion-formulas",
    "title": "Unit conversion exercise",
    "section": "Conversion formulas",
    "text": "Conversion formulas\nImplement the following formulas in your code: \\[\nD =  10  \\cdot \\log_{10} (I) = 10 \\cdot \\log_{10} (e) \\cdot \\ln (I)\\longrightarrow [dB]\n\\] \\[\nI = e^{\\frac{D}{10\\cdot \\log_{10}(e)}} = 10^{\\frac{D}{10}} \\longrightarrow [m^2m^{-2}]  \n\\]\n\ndef lin2db(x):\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\ndef db2lin(x):\n    # YOUR CODE HERE\n    raise NotImplementedError()\n\n\ntimeframes = ['...', '...'] # add your timeframes here (e.g. '1971-01-01/1971-01-15')\naois = [(...,...), (...,...)] # add your AOIs as center points here (lat, lon) \n\n\n# NOTHING IN THIS CELL NEEDS TO BE CHANGED\ndef preprocess_data(dc, nodata_val=-9999, scale_factor=0.1, band='VV'):\n    '''\n    This function preprocesses the Sentinel-1 data by handling the nodata values and scaling the data.\n    Also it only loads the VV band.\n    '''\n    return (dc.where(dc != nodata_val)*scale_factor)[band].median(dim='time')\n\ndef load_data(aoi:list[tuple], timeframe:list[str], spatial_ext:float=0.125, epsg_code:int=4326, spatial_res:float=0.0002) -&gt; list:\n    '''\n    This function helps to load Sentinel-1 data from the EODC STAC API.\n\n    Params:\n    -------\n    - aoi (list[tuple]): List of AOIs as center points (lat, lon)\n    - timeframe (list[str]): List of timeframes in the format 'YYYY-MM-DD/YYYY-MM-DD'\n    - spatial_ext (float): Spatial extent around the center point\n    - epsg_code (int): EPSG code of the coordinate reference system\n    - spatial_res (float): Spatial resolution of the data\n\n    Returns:\n    -------\n    - list: List of xarray datasets\n    '''\n    epsg = CRS.from_epsg(epsg_code) \n    dx = spatial_res \n    datasets = []\n    for area in aoi:\n        for time in timeframe:\n            # Set the spatial extent\n            latmin, latmax = area[0] - spatial_ext, area[0] + spatial_ext\n            lonmin, lonmax = area[1] - spatial_ext, area[1] + spatial_ext\n            bounds = (lonmin, latmin, lonmax, latmax)\n\n            # Search items\n            items = pystac_client.Client.open(\"https://stac.eodc.eu/api/v1\").search(\n                # intersects=geom,\n                bbox=bounds,\n                collections=[\"SENTINEL1_SIG0_20M\"],\n                datetime=time,\n                limit=100,\n            ).item_collection()\n\n            # define a geobox for my region\n            geobox = GeoBox.from_bbox(bounds, crs=epsg, resolution=dx)\n\n            # lazily combine items\n            sig0_dc = odc.stac.stac_load(\n                items,\n                #bbox=bounds,\n                bands=[\"VV\", \"VH\"],\n                chunks={'time': 5, 'x': 600, 'y': 600},\n                epsg=epsg,\n                geobox=geobox,\n                resampling=\"bilinear\",\n            )\n            datasets.append(sig0_dc)\n    return datasets\n\nsig0_00, sig0_01, sig0_10, sig0_11 = load_data(aois, timeframes)\ndcs = [sig0_00, sig0_01, sig0_10, sig0_11]\n\n\n# NOTHING IN THIS CELL NEEDS TO BE CHANGED\ndef calc_mean(array, convert:bool= False) -&gt; dict:\n    '''\n    This function calculates the mean of the Sentinel-1 data.\n    '''\n    if convert:\n        array = db2lin(array) # convert to linear scale\n        mean_lin = array.mean().compute() # compute mean\n        mean = lin2db(mean_lin)# convert back to dB\n    else:\n        mean = array.mean().compute()\n\n    return float(mean)\n\n\nlabels = ['Loc1 Time1', 'Loc1 Time2', 'Loc2 Time1', 'Loc2 Time2'] # add your labels here\n\nmeans_dB = [calc_mean(...) for sig0 in dcs]\nmeans_lin_db = [calc_mean(..., convert=True) for sig0 in dcs]\n\n# Create a Pandas DataFrame\ndata = {\n    'Location': labels * 2,  # Repeat labels for each type (dB and linear)\n    'Mean Value (dB)': means_dB + means_lin_db,  # Concatenate the two lists of means\n    'Type': ['Original dB'] * len(labels) + ['Linear Converted'] * len(labels)  # Type indicator\n}\n\ndf = pd.DataFrame(data)\n\n\n#Startingpoint for your plot \nsns.barplot(data=df, x='...', y='...', hue='...')\n\n# YOUR CODE HERE (to make a nice and meaningful plot)\nraise NotImplementedError()"
  },
  {
    "objectID": "unit_01/01_discover-and-read _exercise.html",
    "href": "unit_01/01_discover-and-read _exercise.html",
    "title": "Discover and Read EO data - Exercise 1",
    "section": "",
    "text": "Synthetic Aperture Radar (SAR) is sensor sensitive to roughness of surface and di-electrical properties of it. Water bodies act as smooth mirror which reflects radar waves, so areas with minimal backscatter can be regarded as so. That being said, SAR interferometry is useful for monitoring floods, as change in backscatter signal indicates change in surface water levels. That can be done by observing the difference in surface water levels in some area of interest over period of several days, weeks or months.\nDisplay quicklook of Sentinel imagery over Thessaly region, Greece in September 2023.\n\nimport pystac_client\nimport folium\nfrom odc import stac as odc_stac\n\neodc_catalog = pystac_client.Client.open(\"https://stac.eodc.eu/api/v1\")\n\neodc_catalog"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html",
    "href": "unit_02/06_backscatter-variability.html",
    "title": "Dielectric Properties of Natural Media",
    "section": "",
    "text": "In this notebook we want to look at how different surfaces like water, forest grasland and cities give us different backscatter.\nWe are going to load backscatering data from Sentinel 1 and we will use the Corine Landcoverdata to get a classification of different surfaces.\nTODO: include time series - how much data changes over time or is affected by certain weather"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html#import-packages",
    "href": "unit_02/06_backscatter-variability.html#import-packages",
    "title": "Dielectric Properties of Natural Media",
    "section": "Import packages",
    "text": "Import packages\n\n# tidy up!\nimport json\n\nimport os\nimport xarray as xr\nimport rioxarray\nimport rasterio\nimport numpy as np\nfrom rasterio.crs import CRS\nimport dask.array as da\nfrom glob import glob\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport folium\nimport matplotlib.patches as patches\nfrom datetime import datetime\nimport pandas as pd\nimport matplotlib.colors as mcolors\nfrom matplotlib.colors import ListedColormap, BoundaryNorm\nimport matplotlib.patches as mpatches\nfrom pyproj import Transformer"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html#load-sentinel-1-data",
    "href": "unit_02/06_backscatter-variability.html#load-sentinel-1-data",
    "title": "Dielectric Properties of Natural Media",
    "section": "Load Sentinel 1 data",
    "text": "Load Sentinel 1 data\nLoad Metadata to get some information on the data. Using .tags() we can extract a lot of useful information like the scale_factor.\nAs we can see frome here the data was captured 8 images between the 5th August 2023 and the 28th October 2023. The image contains Gamma VV values.\nNow we can load the data and and apply preprocessing. From the Metaddata we could extract a scalingfactor of 100 which we now need to apply.\nWe get a xarray.DataSet and convert it to an xarray.DataArray because we only have one variable, the VV backscatter.\nWe have 8 timestemps. For performance reasons we will fous on only on one time becasue the data does not change to much over time.\nWe downsample already in the preprocessing because we do not need all the resolution because we are working with the corine data map and the resolution there is 100 by 100 meters. When we downsample x and y coordinates by 10 we get pixles of size 100 by 100meters which fits perfectly to the\n(insert image of downscaled, normal and corine landcover)\n\ndata_path = Path('~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler').expanduser() # SAT-1 data is inside the saocom_gamma folder but this could change\ntif_files = glob(f\"{data_path}/*.tif\")\n\nfrom pprint import pprint\n\ndef _preprocess(x):\n    file = x.encoding['source']\n\n    print(f\"{os.path.basename(file)}:\")\n    print(json.dumps(rasterio.open(file).tags(), indent=4))\n\n    scale_factor = pd.to_numeric(\n        rasterio.open(x.encoding[\"source\"]).tags().get('scale_factor')\n    )\n    x = x / scale_factor\n    \n    time_value = pd.to_datetime(              # is there a better way to get the date?\n        rasterio.open(x.encoding[\"source\"]).tags().get('time_begin')\n    )\n    x = x.assign_coords(time=time_value).expand_dims(\"time\")\n\n    return x.rename(\n        {\"band_data\": \"sig0\"}\n    ).squeeze(\"band\").drop_vars(\"band\")\n\n\nsig0_ds_large = xr.open_mfdataset(\n    '~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler/*.tif',\n    engine=\"rasterio\",\n    combine='nested',\n    concat_dim=\"time\",\n    preprocess=_preprocess\n)\n\nsig0_ds_large = sig0_ds_large[list(sig0_ds_large.data_vars.keys())[0]]\nsig0_ds_large\n\nD20230805_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"049743\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_2_A01_gmr_jobfile_A0105_log_20231201_034630.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20230805T165122_20230805T165147_049743_05FB3C_64DB.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 03:46:31\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-08-05 16:51:22\",\n    \"time_end\": \"2023-08-05 16:51:47\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20230817_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"049918\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_2_A01_gmr_jobfile_A0105_log_20231201_065607.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20230817T165122_20230817T165147_049918_060121_784A.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 06:56:08\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-08-17 16:51:22\",\n    \"time_end\": \"2023-08-17 16:51:47\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20230829_165123--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050093\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_2_A01_gmr_jobfile_A0105_log_20231201_073256.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20230829T165123_20230829T165148_050093_060726_855E.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 07:32:57\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-08-29 16:51:23\",\n    \"time_end\": \"2023-08-29 16:51:48\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20230910_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050268\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_4_A01_gmr_jobfile_A0105_log_20231201_080609.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20230910T165124_20230910T165149_050268_060D16_BAC4.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 08:06:10\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-09-10 16:51:24\",\n    \"time_end\": \"2023-09-10 16:51:49\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20230922_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050443\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_7_A01_gmr_jobfile_A0105_log_20231201_082733.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20230922T165124_20230922T165149_050443_06130C_7915.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 08:27:33\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-09-22 16:51:24\",\n    \"time_end\": \"2023-09-22 16:51:49\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20231004_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050618\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_13_A01_gmr_jobfile_A0105_log_20231201_035056.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20231004T165124_20231004T165149_050618_06190F_38E7.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 03:50:57\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-10-04 16:51:24\",\n    \"time_end\": \"2023-10-04 16:51:49\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20231016_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050793\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_14_A01_gmr_jobfile_A0105_log_20231201_051314.xml\",\n    \"orbit_aux_file\": \"POE\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20231016T165124_20231016T165149_050793_061F17_EF2F.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"True\",\n    \"processing_date\": \"2023-12-01 05:13:15\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-10-16 16:51:24\",\n    \"time_end\": \"2023-10-16 16:51:49\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\nD20231028_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif:\n{\n    \"abs_orbit_number\": \"050968\",\n    \"band_1\": \"Gamma0_VV\",\n    \"border_noise_removed\": \"True\",\n    \"creator\": \"TUWGEO\",\n    \"distanceuom\": \"m\",\n    \"distancevalue\": \"10\",\n    \"equi7_tile\": \"EU010M_E052N015T1\",\n    \"ext_dem\": \"/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif\",\n    \"grid\": \"Equi7 Grid\",\n    \"gtc_applied\": \"True\",\n    \"log_file\": \"tasklist_13_A01_gmr_jobfile_A0105_log_20231201_020603.xml\",\n    \"orbit_aux_file\": \"None\",\n    \"parent_data_file\": \"S1A_IW_GRDH_1SDV_20231028T165124_20231028T165149_050968_062503_8D6A.zip\",\n    \"polarisation\": \"VV\",\n    \"precise_orbit_applied\": \"False\",\n    \"processing_date\": \"2023-12-01 02:06:04\",\n    \"processing_software\": \"SGRT\",\n    \"processing_software_version\": \"A0105-2.4.9.post.dev6.pre\",\n    \"rel_orbit_number\": \"146\",\n    \"rtf_applied\": \"True\",\n    \"sat_product_id\": \"S1AIWGRDH1VVA\",\n    \"scale_factor\": \"100.0\",\n    \"thermal_noise_removed\": \"True\",\n    \"time_begin\": \"2023-10-28 16:51:24\",\n    \"time_end\": \"2023-10-28 16:51:49\",\n    \"variable_name\": \"GMR\",\n    \"AREA_OR_POINT\": \"Area\"\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'sig0' (time: 8, y: 10000, x: 10000)&gt; Size: 6GB\ndask.array&lt;concatenate, shape=(8, 10000, 10000), dtype=float64, chunksize=(1, 1, 10000), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 80kB 5.2e+06 5.2e+06 5.2e+06 ... 5.3e+06 5.3e+06\n  * y            (y) float64 80kB 1.6e+06 1.6e+06 1.6e+06 ... 1.5e+06 1.5e+06\n    spatial_ref  int64 8B 0\n  * time         (time) datetime64[ns] 64B 2023-08-05T16:51:22 ... 2023-10-28...xarray.DataArray'sig0'time: 8y: 10000x: 10000dask.array&lt;chunksize=(1, 1, 10000), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n5.96 GiB\n78.12 kiB\n\n\nShape\n(8, 10000, 10000)\n(1, 1, 10000)\n\n\nDask graph\n80000 chunks in 41 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                                                                           10000 10000 8\n\n\n\n\nCoordinates: (4)x(x)float645.2e+06 5.2e+06 ... 5.3e+06 5.3e+06array([5200005., 5200015., 5200025., ..., 5299975., 5299985., 5299995.])y(y)float641.6e+06 1.6e+06 ... 1.5e+06 1.5e+06array([1599995., 1599985., 1599975., ..., 1500025., 1500015., 1500005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time(time)datetime64[ns]2023-08-05T16:51:22 ... 2023-10-...array(['2023-08-05T16:51:22.000000000', '2023-08-17T16:51:22.000000000',\n       '2023-08-29T16:51:23.000000000', '2023-09-10T16:51:24.000000000',\n       '2023-09-22T16:51:24.000000000', '2023-10-04T16:51:24.000000000',\n       '2023-10-16T16:51:24.000000000', '2023-10-28T16:51:24.000000000'],\n      dtype='datetime64[ns]')Indexes: (3)xPandasIndexPandasIndex(Index([5200005.0, 5200015.0, 5200025.0, 5200035.0, 5200045.0, 5200055.0,\n       5200065.0, 5200075.0, 5200085.0, 5200095.0,\n       ...\n       5299905.0, 5299915.0, 5299925.0, 5299935.0, 5299945.0, 5299955.0,\n       5299965.0, 5299975.0, 5299985.0, 5299995.0],\n      dtype='float64', name='x', length=10000))yPandasIndexPandasIndex(Index([1599995.0, 1599985.0, 1599975.0, 1599965.0, 1599955.0, 1599945.0,\n       1599935.0, 1599925.0, 1599915.0, 1599905.0,\n       ...\n       1500095.0, 1500085.0, 1500075.0, 1500065.0, 1500055.0, 1500045.0,\n       1500035.0, 1500025.0, 1500015.0, 1500005.0],\n      dtype='float64', name='y', length=10000))timePandasIndexPandasIndex(DatetimeIndex(['2023-08-05 16:51:22', '2023-08-17 16:51:22',\n               '2023-08-29 16:51:23', '2023-09-10 16:51:24',\n               '2023-09-22 16:51:24', '2023-10-04 16:51:24',\n               '2023-10-16 16:51:24', '2023-10-28 16:51:24'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)\n\n\n\nbounding_box = {\n    'x_min': 5_280_000.0,\n    'x_max': 5_295_000.0,\n    'y_min': 1_560_000.0,\n    'y_max': 1_570_000.0\n}\n\n\nimg = sig0_ds_large.isel(time=0) .coarsen(x=10, y=10, boundary='pad').mean()\n\nfig, ax = plt.subplots(figsize=(15, 10))\n\nimg.plot(ax=ax, robust=True)\n\nrect = patches.Rectangle(\n    (bounding_box['x_min'], bounding_box['y_min']),\n    bounding_box['x_max'] - bounding_box['x_min'],\n    bounding_box['y_max'] - bounding_box['y_min'],\n    linewidth=2,\n    edgecolor='red',\n    facecolor='none'\n)\nax.add_patch(rect)\nax.set_aspect('equal')\n\nplt.show()\n\n\n\n\n\n\n\n\n\nsig0_ds = sig0_ds_large.sel(\n    x=slice(bounding_box['x_min'], bounding_box['x_max']),\n    y=slice(bounding_box['y_max'], bounding_box['y_min'])\n)\nsig0_ds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'sig0' (time: 8, y: 1000, x: 1500)&gt; Size: 96MB\ndask.array&lt;getitem, shape=(8, 1000, 1500), dtype=float64, chunksize=(1, 1, 1500), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 12kB 5.28e+06 5.28e+06 ... 5.295e+06 5.295e+06\n  * y            (y) float64 8kB 1.57e+06 1.57e+06 ... 1.56e+06 1.56e+06\n    spatial_ref  int64 8B 0\n  * time         (time) datetime64[ns] 64B 2023-08-05T16:51:22 ... 2023-10-28...xarray.DataArray'sig0'time: 8y: 1000x: 1500dask.array&lt;chunksize=(1, 1, 1500), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n91.55 MiB\n11.72 kiB\n\n\nShape\n(8, 1000, 1500)\n(1, 1, 1500)\n\n\nDask graph\n8000 chunks in 42 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                                                                           1500 1000 8\n\n\n\n\nCoordinates: (4)x(x)float645.28e+06 5.28e+06 ... 5.295e+06array([5280005., 5280015., 5280025., ..., 5294975., 5294985., 5294995.])y(y)float641.57e+06 1.57e+06 ... 1.56e+06array([1569995., 1569985., 1569975., ..., 1560025., 1560015., 1560005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time(time)datetime64[ns]2023-08-05T16:51:22 ... 2023-10-...array(['2023-08-05T16:51:22.000000000', '2023-08-17T16:51:22.000000000',\n       '2023-08-29T16:51:23.000000000', '2023-09-10T16:51:24.000000000',\n       '2023-09-22T16:51:24.000000000', '2023-10-04T16:51:24.000000000',\n       '2023-10-16T16:51:24.000000000', '2023-10-28T16:51:24.000000000'],\n      dtype='datetime64[ns]')Indexes: (3)xPandasIndexPandasIndex(Index([5280005.0, 5280015.0, 5280025.0, 5280035.0, 5280045.0, 5280055.0,\n       5280065.0, 5280075.0, 5280085.0, 5280095.0,\n       ...\n       5294905.0, 5294915.0, 5294925.0, 5294935.0, 5294945.0, 5294955.0,\n       5294965.0, 5294975.0, 5294985.0, 5294995.0],\n      dtype='float64', name='x', length=1500))yPandasIndexPandasIndex(Index([1569995.0, 1569985.0, 1569975.0, 1569965.0, 1569955.0, 1569945.0,\n       1569935.0, 1569925.0, 1569915.0, 1569905.0,\n       ...\n       1560095.0, 1560085.0, 1560075.0, 1560065.0, 1560055.0, 1560045.0,\n       1560035.0, 1560025.0, 1560015.0, 1560005.0],\n      dtype='float64', name='y', length=1000))timePandasIndexPandasIndex(DatetimeIndex(['2023-08-05 16:51:22', '2023-08-17 16:51:22',\n               '2023-08-29 16:51:23', '2023-09-10 16:51:24',\n               '2023-09-22 16:51:24', '2023-10-04 16:51:24',\n               '2023-10-16 16:51:24', '2023-10-28 16:51:24'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)\n\n\nTo get an idea of the region we are looking at we want to display it. Using rubust=True will use the 2nd and 98th percentiles of the data to compute the color limits.\n\nsig0_ds.isel(time=0).plot(robust=True).axes.set_aspect('equal')"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html#load-corine-landcover-data",
    "href": "unit_02/06_backscatter-variability.html#load-corine-landcover-data",
    "title": "Dielectric Properties of Natural Media",
    "section": "Load Corine Landcover data",
    "text": "Load Corine Landcover data\nWe load the Corine Land Cover data which classifies the landcover of europa in 44 different areas.\nWe want to work with the Equi7 grid because it preserves geometric accuracy and minimises data oversampling over surfaces. So we need to convert the Corine Land Cover map to this coordinate system.\n\nLoading data\n\ncorine_path = Path('~/shared/datasets/rs/datapool/mrs/Corine_Land_Cover_2018.tif').expanduser()\n\nprint(f\"CRS :{rasterio.open(corine_path).meta['crs']}\")\n\ncorine_ds_large = (\n    xr.open_dataset(corine_path,engine=\"rasterio\")\n    .rename({\"band_data\": \"land_cover\"})[\"land_cover\"]\n    .squeeze()\n)\n\ncorine_ds_large\n\nCRS :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'land_cover' (y: 46000, x: 65000)&gt; Size: 12GB\n[2990000000 values with dtype=float32]\nCoordinates:\n    band         int64 8B 1\n  * x            (x) float64 520kB 9e+05 9.002e+05 9.002e+05 ... 7.4e+06 7.4e+06\n  * y            (y) float64 368kB 5.5e+06 5.5e+06 5.5e+06 ... 9.002e+05 9e+05\n    spatial_ref  int64 8B ...\nAttributes:\n    DataType:                Thematic\n    AREA_OR_POINT:           Area\n    RepresentationType:      THEMATIC\n    STATISTICS_COVARIANCES:  136.429646247598\n    STATISTICS_MAXIMUM:      48\n    STATISTICS_MEAN:         25.753373398066\n    STATISTICS_MINIMUM:      1\n    STATISTICS_SKIPFACTORX:  1\n    STATISTICS_SKIPFACTORY:  1\n    STATISTICS_STDDEV:       11.680310194836xarray.DataArray'land_cover'y: 46000x: 65000...[2990000000 values with dtype=float32]Coordinates: (4)band()int641array(1)x(x)float649e+05 9.002e+05 ... 7.4e+06 7.4e+06array([ 900050.,  900150.,  900250., ..., 7399750., 7399850., 7399950.])y(y)float645.5e+06 5.5e+06 ... 9.002e+05 9e+05array([5499950., 5499850., 5499750., ...,  900250.,  900150.,  900050.])spatial_ref()int64...crs_wkt :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101004reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989projected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0spatial_ref :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]GeoTransform :900000.0 100.0 0.0 5500000.0 0.0 -100.0[1 values with dtype=int64]Indexes: (2)xPandasIndexPandasIndex(Index([ 900050.0,  900150.0,  900250.0,  900350.0,  900450.0,  900550.0,\n        900650.0,  900750.0,  900850.0,  900950.0,\n       ...\n       7399050.0, 7399150.0, 7399250.0, 7399350.0, 7399450.0, 7399550.0,\n       7399650.0, 7399750.0, 7399850.0, 7399950.0],\n      dtype='float64', name='x', length=65000))yPandasIndexPandasIndex(Index([5499950.0, 5499850.0, 5499750.0, 5499650.0, 5499550.0, 5499450.0,\n       5499350.0, 5499250.0, 5499150.0, 5499050.0,\n       ...\n        900950.0,  900850.0,  900750.0,  900650.0,  900550.0,  900450.0,\n        900350.0,  900250.0,  900150.0,  900050.0],\n      dtype='float64', name='y', length=46000))Attributes: (10)DataType :ThematicAREA_OR_POINT :AreaRepresentationType :THEMATICSTATISTICS_COVARIANCES :136.429646247598STATISTICS_MAXIMUM :48STATISTICS_MEAN :25.753373398066STATISTICS_MINIMUM :1STATISTICS_SKIPFACTORX :1STATISTICS_SKIPFACTORY :1STATISTICS_STDDEV :11.680310194836\n\n\n\n\nSelect area of interest\n\ntransformer = Transformer.from_crs(\"EPSG:27704\", \"EPSG:3035\", always_xy=True)\n\nbbox_27704 = sig0_ds_large.rio.transform_bounds(sig0_ds_large.rio.crs)\nbbox_3035 = transformer.transform_bounds(*bbox_27704)\n\nprint(bbox_27704)\nprint(bbox_3035)\n\nx_min, y_min, x_max, y_max = bbox_3035\ncorine_ds = corine_ds_large.sel(x=slice(x_min, x_max), y=slice(y_max, y_min))\n\n(5200000.0, 1500000.0, 5300000.0, 1600000.0)\n(4728101.713653255, 2679708.979351567, 4844562.869274702, 2796700.500845548)\n\n\n\n\nAlignment of the datasets (raster + pixles)\n\ndef print_details(ds, ds_name):\n    print(f\"{ds_name}:\")\n    print(f\"CRS: {ds.rio.crs}\")\n    print(f\"Bounds: {ds.rio.bounds()}\")\n    print(f\"Pixel size: {ds.rio.resolution()}\\n\")\n\n\nprint_details(corine_ds, \"corine_ds\")\nprint_details(sig0_ds, \"sig0_ds\")\n\ncorine_ds:\nCRS: PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]\nBounds: (4728100.0, 2679700.0, 4844600.0, 2796700.0)\nPixel size: (100.0, -100.0)\n\nsig0_ds:\nCRS: EPSG:27704\nBounds: (5280000.0, 1560000.0, 5295000.0, 1570000.0)\nPixel size: (10.0, -10.0)\n\n\n\nReprojecting does a whole lot for us\n\ncorine_ds = corine_ds.rio.reproject_match(sig0_ds)\n\nprint_details(corine_ds, \"corine_ds\")\nprint_details(sig0_ds, \"sig0_ds\")\n\ncorine_ds:\nCRS: EPSG:27704\nBounds: (5280000.0, 1560000.0, 5295000.0, 1570000.0)\nPixel size: (10.0, -10.0)\n\nsig0_ds:\nCRS: EPSG:27704\nBounds: (5280000.0, 1560000.0, 5295000.0, 1570000.0)\nPixel size: (10.0, -10.0)\n\n\n\n\n\nColormapping and Encoding\nThe color mapping is stored in a json file under assets. The encoding can be found here: https://collections.sentinel-hub.com/corine-land-cover/readme.html\n\nwith open('../assets/06_color_mapping.json', 'r') as f:\n    color_mapping_data = json.load(f)\n\ncolor_mapping = {item['value']: item for item in color_mapping_data['land_cover']}\n\ncolors = [info['color'] for info in color_mapping.values()]\ncategories = [info['value'] for info in color_mapping.values()]\n\ncmap  =ListedColormap(colors)\nnorm = BoundaryNorm(categories + [max(categories) + 1], len(categories))\n\n\nmax_length = 50\nindentation = ' ' * 7\n\nunique_values = corine_ds.values[~np.isnan(corine_ds.values)].astype(int)\n\nhandles = [\n    mpatches.Patch(color=info['color'], \n                   label=f'{info[\"value\"]} - ' + \n                   (info[\"label\"] if len(info[\"label\"]) &lt;= max_length \n                    else f'{info[\"label\"][:max_length]}-\\n{indentation}{info[\"label\"][max_length:]}'))    \n    for info in color_mapping.values() if info['value'] in unique_values\n]\n\ncorine_ds.plot(figsize=(10, 10), cmap=cmap, norm=norm, add_colorbar=False).axes.set_aspect('equal')\nplt.legend(handles=handles, bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0., fontsize=7)\nplt.show()\n\n\n\n\n\n\n\n\nNow we can combine the datasets to one xarray dataset.\n\nfs = xr.merge([sig0_ds,corine_ds]) .drop(\"band\")\nfs\n\n/tmp/ipykernel_79562/1138911145.py:1: DeprecationWarning: dropping variables using `drop` is deprecated; use drop_vars.\n  fs = xr.merge([sig0_ds,corine_ds]) .drop(\"band\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.Dataset&gt; Size: 102MB\nDimensions:      (x: 1500, y: 1000, time: 8)\nCoordinates:\n  * x            (x) float64 12kB 5.28e+06 5.28e+06 ... 5.295e+06 5.295e+06\n  * y            (y) float64 8kB 1.57e+06 1.57e+06 ... 1.56e+06 1.56e+06\n    spatial_ref  int64 8B 0\n  * time         (time) datetime64[ns] 64B 2023-08-05T16:51:22 ... 2023-10-28...\nData variables:\n    sig0         (time, y, x) float64 96MB dask.array&lt;chunksize=(1, 1, 1500), meta=np.ndarray&gt;\n    land_cover   (y, x) float32 6MB 12.0 12.0 12.0 12.0 ... 35.0 35.0 35.0 35.0xarray.DatasetDimensions:x: 1500y: 1000time: 8Coordinates: (4)x(x)float645.28e+06 5.28e+06 ... 5.295e+06array([5280005., 5280015., 5280025., ..., 5294975., 5294985., 5294995.])y(y)float641.57e+06 1.57e+06 ... 1.56e+06array([1569995., 1569985., 1569975., ..., 1560025., 1560015., 1560005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time(time)datetime64[ns]2023-08-05T16:51:22 ... 2023-10-...array(['2023-08-05T16:51:22.000000000', '2023-08-17T16:51:22.000000000',\n       '2023-08-29T16:51:23.000000000', '2023-09-10T16:51:24.000000000',\n       '2023-09-22T16:51:24.000000000', '2023-10-04T16:51:24.000000000',\n       '2023-10-16T16:51:24.000000000', '2023-10-28T16:51:24.000000000'],\n      dtype='datetime64[ns]')Data variables: (2)sig0(time, y, x)float64dask.array&lt;chunksize=(1, 1, 1500), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n91.55 MiB\n11.72 kiB\n\n\nShape\n(8, 1000, 1500)\n(1, 1, 1500)\n\n\nDask graph\n8000 chunks in 42 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                                                                           1500 1000 8\n\n\n\n\nland_cover(y, x)float3212.0 12.0 12.0 ... 35.0 35.0 35.0DataType :ThematicAREA_OR_POINT :AreaRepresentationType :THEMATICSTATISTICS_COVARIANCES :136.429646247598STATISTICS_MAXIMUM :48STATISTICS_MEAN :25.753373398066STATISTICS_MINIMUM :1STATISTICS_SKIPFACTORX :1STATISTICS_SKIPFACTORY :1STATISTICS_STDDEV :11.680310194836array([[12., 12., 12., ..., 41., 41., 41.],\n       [12., 12., 12., ..., 41., 41., 41.],\n       [12., 12., 12., ..., 41., 41., 41.],\n       ...,\n       [18., 18., 18., ..., 35., 35., 35.],\n       [18., 18., 18., ..., 35., 35., 35.],\n       [18., 18., 18., ..., 35., 35., 35.]], dtype=float32)Indexes: (3)xPandasIndexPandasIndex(Index([5280005.0, 5280015.0, 5280025.0, 5280035.0, 5280045.0, 5280055.0,\n       5280065.0, 5280075.0, 5280085.0, 5280095.0,\n       ...\n       5294905.0, 5294915.0, 5294925.0, 5294935.0, 5294945.0, 5294955.0,\n       5294965.0, 5294975.0, 5294985.0, 5294995.0],\n      dtype='float64', name='x', length=1500))yPandasIndexPandasIndex(Index([1569995.0, 1569985.0, 1569975.0, 1569965.0, 1569955.0, 1569945.0,\n       1569935.0, 1569925.0, 1569915.0, 1569905.0,\n       ...\n       1560095.0, 1560085.0, 1560075.0, 1560065.0, 1560055.0, 1560045.0,\n       1560035.0, 1560025.0, 1560015.0, 1560005.0],\n      dtype='float64', name='y', length=1000))timePandasIndexPandasIndex(DatetimeIndex(['2023-08-05 16:51:22', '2023-08-17 16:51:22',\n               '2023-08-29 16:51:23', '2023-09-10 16:51:24',\n               '2023-09-22 16:51:24', '2023-10-04 16:51:24',\n               '2023-10-16 16:51:24', '2023-10-28 16:51:24'],\n              dtype='datetime64[ns]', name='time', freq=None))Attributes: (0)\n\n\n\n\nWe create a Histogram for a specific landcover backscatter\n\nwaterbodies_mask = (fs.land_cover == 41)\n\nwaterbodies_mask.plot().axes.set_aspect('equal')\n\n\n\n\n\n\n\n\n\nwaterbodies_sig0 = fs.sig0.isel(time=0).where(waterbodies_mask)\nwaterbodies_sig0.plot(robust=True).axes.set_aspect('equal')\n\n\n\n\n\n\n\n\n\nwaterbodies_sig0.plot.hist(bins=30, edgecolor='black')\n\n(array([5.0000e+00, 1.2000e+01, 3.8000e+01, 1.5200e+02, 4.7300e+02,\n        1.2270e+03, 3.5930e+03, 1.0341e+04, 2.4635e+04, 4.4577e+04,\n        6.7412e+04, 7.5855e+04, 5.4059e+04, 2.0049e+04, 5.0760e+03,\n        2.8380e+03, 3.5350e+03, 4.7910e+03, 5.5180e+03, 4.6290e+03,\n        2.5030e+03, 7.5700e+02, 1.6400e+02, 4.8000e+01, 3.3000e+01,\n        1.6000e+01, 1.4000e+01, 1.7000e+01, 7.0000e+00, 9.0000e+00]),\n array([-3.79099998e+01, -3.62603340e+01, -3.46106682e+01, -3.29609985e+01,\n        -3.13113327e+01, -2.96616669e+01, -2.80120010e+01, -2.63623352e+01,\n        -2.47126675e+01, -2.30629997e+01, -2.14133339e+01, -1.97636681e+01,\n        -1.81140022e+01, -1.64643345e+01, -1.48146687e+01, -1.31650009e+01,\n        -1.15153351e+01, -9.86566925e+00, -8.21600151e+00, -6.56633568e+00,\n        -4.91666794e+00, -3.26700211e+00, -1.61733627e+00,  3.23295593e-02,\n         1.68199539e+00,  3.33166504e+00,  4.98133087e+00,  6.63099670e+00,\n         8.28066254e+00,  9.93032837e+00,  1.15799999e+01]),\n &lt;BarContainer object of 30 artists&gt;)"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html#function-for-plotting",
    "href": "unit_02/06_backscatter-variability.html#function-for-plotting",
    "title": "Dielectric Properties of Natural Media",
    "section": "Function for plotting",
    "text": "Function for plotting\n\ndef calc_histogram(corine_ds, sig0_ds, feature_codes):\n\n    all_backscatter_values = []\n    mean_var = {}\n\n    for code in feature_codes:\n        if code not in color_mapping:\n            print(f\"Feature code {code} is not in the color mapping.\")\n            break\n        \n        mask = (corine_ds == code)\n\n        backscatter_values = sig0_ds.where(mask, drop=True).values.flatten()\n        backscatter_values = backscatter_values[~np.isnan(backscatter_values)]\n        \n        if len(backscatter_values) == 0:\n            continue \n        \n        all_backscatter_values.extend(backscatter_values)\n\n        mean_value = np.mean(backscatter_values)\n        variance_value = np.var(backscatter_values)\n\n        mean_var[code] = {\n            'mean': mean_value,\n            'variance': variance_value\n        }\n\n    global_min = np.min(all_backscatter_values)\n    global_max = np.max(all_backscatter_values)\n\n    return global_min, global_max, mean_var\n\ndef plot_mask(ax, mask, feature_name):\n    mask.plot(ax=ax)\n    ax.set_title(f\"{feature_name} Mask\")\n    ax.set_xlabel('x coordinate [meter]', labelpad=10)\n    ax.set_ylabel('y coordinate [meter]', labelpad=10)\n    ax.set_aspect('equal')\n\ndef plot_sig0(ax, sig0, feature_name):\n    sig0.plot(ax=ax, robust=True)\n    ax.set_title(f\"{feature_name} sig0\")\n    ax.set_xlabel('x coordinate [meter]', labelpad=10)\n    ax.set_ylabel('y coordinate [meter]', labelpad=10)\n    ax.set_aspect('equal')\n    cbar = ax.collections[0].colorbar\n    cbar.set_label('Backscatter Value (dB)', labelpad=10)\n\ndef plot_histogram(ax, sig0, feature_name, x_min, x_max, mean_var):\n    num_bins = int(np.ceil((x_max - x_min)))\n    bin_edges = np.linspace(x_min, x_max, num_bins + 1)\n    \n    text_str = f\"Mean: {mean_var['mean']:.2f}\\nVariance: {mean_var['variance']:.2f}\"\n\n    sig0.plot.hist(ax=ax, bins=bin_edges, edgecolor='black')\n    ax.set_title(f\"{feature_name} sig0 Histogram\")\n    ax.set_xlabel('sig0 Value')\n    ax.set_ylabel('Frequency')\n    ax.set_xlim(x_min, x_max)\n    ax.text(0.95, 0.95, text_str, transform=ax.transAxes, \n            verticalalignment='top', horizontalalignment='right',\n            bbox=dict(facecolor='white', alpha=0.5))\n\ndef plot_classes(fs, feature_codes):\n\n    corine_ds = fs.land_cover\n    sig0_ds=fs.sig0 .mean(dim='time') .compute() # or use .isel(time=0) for one timevalue\n    \n    x_min, x_max, mean_var = calc_histogram(corine_ds, sig0_ds, feature_codes)\n\n    n_rows = len(feature_codes)\n    n_cols = 3\n    \n    axes = plt.subplots(n_rows, n_cols, figsize=(15, n_rows * 4))[1].flatten()\n\n    for idx, code in enumerate(feature_codes):\n\n        feature_info = color_mapping[code]\n        feature_color = feature_info['color']\n        feature_name = feature_info['label']\n        \n        # mask\n        mask = (corine_ds == code).persist()      #.compute()    # a little bit faster with .compute()\n        plot_mask(axes[idx * 3], mask, feature_name)\n\n        # backscatter\n        feature_backscatter = sig0_ds.where(mask)\n        plot_sig0(axes[idx * 3 + 1], feature_backscatter, feature_name)\n\n        # histogramm\n        plot_histogram(axes[idx * 3 + 2], feature_backscatter, feature_name, x_min, x_max, mean_var[code])\n        \n\n    plt.tight_layout()\n    plt.show()\n\nThe function can be used to plot the mask, the actuall backscatter and the histogram of the backscattering values of the corresponding landtype. Be careful! Dont forget the frequency count on the y axis. They are different form each plot.\n\n# specify the features that should be selected:\nfeature_codes = [2,23,24,41]\n\nplot_classes(fs, feature_codes)"
  },
  {
    "objectID": "unit_02/06_backscatter-variability.html#interactive-histograms-over-time-using-holoviews",
    "href": "unit_02/06_backscatter-variability.html#interactive-histograms-over-time-using-holoviews",
    "title": "Dielectric Properties of Natural Media",
    "section": "Interactive Histograms over time using HoloViews",
    "text": "Interactive Histograms over time using HoloViews\n\nimport hvplot.xarray\n\nfs=fs.compute()\n\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\nfs.sig0 .hvplot.image(x=\"x\", y=\"y\", groupby=\"time\", clim=(robust_min, robust_max), aspect=\"equal\", framewise=False).opts(\n        cmap=\"viridis\", colorbar=True,\n        tools=[\"hover\"])\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\n\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\nimg = fs.sig0.isel(time=0).hvplot.image(x=\"x\", y=\"y\", clim=(robust_min, robust_max), aspect=\"equal\", framewise=False).opts(\n        cmap=\"viridis\", colorbar=True,frame_width=600,\n        tools=[\"hover\"])\n\n\ndef selected_hist(x_range, y_range):\n\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    \n    return hvop.histogram(obj, num_bins=50, normed=True).opts(height=472, width=200)\n\nrangexy = hv.streams.RangeXY(source=img)\n\nimg &lt;&lt; hv.DynamicMap(selected_hist, streams=[rangexy])\n\n\n\n\n\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\nfrom holoviews.streams import RangeXY\nfrom holoviews import opts\n\nhv_ds = hv.Dataset(fs.sig0.isel(time=0))\nimg = hv_ds.to(hv.Image, [\"x\", \"y\"])\n\ndef create_image(x_range, y_range):\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    return hv.Image(obj).opts(\n        aspect=\"equal\", cmap=\"viridis\", colorbar=True, \n        height=400, tools=[\"hover\"]\n    )                     \n\nrangexy = RangeXY()\n\nhv.DynamicMap(create_image, streams=[rangexy]).hist(normed=True)\n\nWARNING:param.RasterPlot07141: Due to internal constraints, when aspect and width/height is set, the bokeh backend uses those values as frame_width/frame_height instead. This ensures the aspect is respected, but means that the plot might be slightly larger than anticipated. Set the frame_width/frame_height explicitly to suppress this warning.\n\n\n\n\n\n\nDashboard all landcover over time\n\nimport holoviews as hv\nimport hvplot.xarray\nimport numpy as np\nfrom holoviews import opts\nfrom holoviews.streams import RangeXY\n\nhv.extension('bokeh')\n\ntime = np.arange(8)\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\nrangexy = RangeXY()\n\ndef load_image(time, x_range, y_range):\n\n    hv_ds = hv.Dataset(fs.sig0.isel(time=time))\n    img = hv_ds.to(hv.Image, [\"x\", \"y\"])\n\n    if x_range and y_range:\n        img = img.select(x=x_range, y=y_range)\n\n    return hv.Image(img).opts(\n        cmap=\"viridis\", colorbar=True,frame_width=368,\n        tools=[\"hover\"], clim=(robust_min, robust_max), aspect=\"equal\")\n\n\n# bin_edges = [i for i in range(int(robust_min), int(robust_max))]  # Example bin edges\nbin_edges = [i + j * 0.5 for i in range(int(robust_min)-2, int(robust_max)+2) for j in range(2)] \n\nfinished_img = hv.DynamicMap(\n    load_image, \n    kdims=['time'], \n    streams=[rangexy]\n).redim.values(time=time).hist(normed=True, bins=bin_edges)\n\nfinished_img\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\n\n\n\n\nDashboard backscatter of different landcover over time\n\nimport holoviews as hv\nimport hvplot.xarray\nimport numpy as np\nfrom holoviews import opts\nfrom holoviews.streams import RangeXY\n\nhv.extension('bokeh')\n\ntime = np.arange(8)\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\nrangexy = RangeXY()\n\ndef load_image(time, x_range, y_range):\n\n    hv_ds = hv.Dataset(fs.sig0.isel(time=time))\n    img = hv_ds.to(hv.Image, [\"x\", \"y\"])\n\n    if x_range and y_range:\n        img = img.select(x=x_range, y=y_range)\n\n    return hv.Image(img).opts(\n        cmap=\"viridis\", colorbar=True,frame_width=368,\n        tools=[\"hover\"], clim=(robust_min, robust_max), aspect=\"equal\")\n\n\n# bin_edges = [i for i in range(int(robust_min), int(robust_max))]  # Example bin edges\nbin_edges = [i + j * 0.5 for i in range(int(robust_min)-2, int(robust_max)+2) for j in range(2)] \n\nfinished_img = hv.DynamicMap(\n    load_image, \n    kdims=['time'], \n    streams=[rangexy]\n).redim.values(time=time).hist(normed=True, bins=bin_edges)\n\nfinished_img\n\n\n\nold approaches\n\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\n\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\nimg = fs.sig0 .hvplot.image(x=\"x\", y=\"y\", groupby=\"time\", clim=(robust_min, robust_max), aspect=\"equal\", framewise=False).opts(\n        cmap=\"viridis\", colorbar=True,\n        tools=[\"hover\"])\n\ndef selected_hist(x_range, y_range):\n\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    \n    return hvop.histogram(obj, num_bins=50, normed=True).opts(height=472, width=200)\n\nrangexy = hv.streams.RangeXY(source=img)\n\nimg &lt;&lt; hv.DynamicMap(selected_hist, streams=[rangexy])\n\n\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/IPython/core/formatters.py:977, in MimeBundleFormatter.__call__(self, obj, include, exclude)\n    974     method = get_real_method(obj, self.print_method)\n    976     if method is not None:\n--&gt; 977         return method(include=include, exclude=exclude)\n    978     return None\n    979 else:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/dimension.py:1275, in Dimensioned._repr_mimebundle_(self, include, exclude)\n   1268 def _repr_mimebundle_(self, include=None, exclude=None):\n   1269     \"\"\"\n   1270     Resolves the class hierarchy for the class rendering the\n   1271     object using any display hooks registered on Store.display\n   1272     hooks.  The output of all registered display_hooks is then\n   1273     combined and returned.\n   1274     \"\"\"\n-&gt; 1275     return Store.render(self)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/options.py:1428, in Store.render(cls, obj)\n   1426 data, metadata = {}, {}\n   1427 for hook in hooks:\n-&gt; 1428     ret = hook(obj)\n   1429     if ret is None:\n   1430         continue\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:287, in pprint_display(obj)\n    285 if not ip.display_formatter.formatters['text/plain'].pprint:\n    286     return None\n--&gt; 287 return display(obj, raw_output=True)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:258, in display(obj, raw_output, **kwargs)\n    256 elif isinstance(obj, (Layout, NdLayout, AdjointLayout)):\n    257     with option_state(obj):\n--&gt; 258         output = layout_display(obj)\n    259 elif isinstance(obj, (HoloMap, DynamicMap)):\n    260     with option_state(obj):\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:149, in display_hook.&lt;locals&gt;.wrapped(element)\n    147 try:\n    148     max_frames = OutputSettings.options['max_frames']\n--&gt; 149     mimebundle = fn(element, max_frames=max_frames)\n    150     if mimebundle is None:\n    151         return {}, {}\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:223, in layout_display(layout, max_frames)\n    220     max_frame_warning(max_frames)\n    221     return None\n--&gt; 223 return render(layout)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:76, in render(obj, **kwargs)\n     73 if renderer.fig == 'pdf':\n     74     renderer = renderer.instance(fig='png')\n---&gt; 76 return renderer.components(obj, **kwargs)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:397, in Renderer.components(self, obj, fmt, comm, **kwargs)\n    395 if embed or config.comms == 'default':\n    396     return self._render_panel(plot, embed, comm)\n--&gt; 397 return self._render_ipywidget(plot)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:419, in Renderer._render_ipywidget(self, plot)\n    417 def _render_ipywidget(self, plot):\n    418     # Handle rendering object as ipywidget\n--&gt; 419     widget = ipywidget(plot, combine_events=True)\n    420     if hasattr(widget, '_repr_mimebundle_'):\n    421         return widget._repr_mimebundle_(), {}\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/io/notebook.py:561, in ipywidget(obj, doc, **kwargs)\n    559 from ..pane import panel\n    560 doc = doc if doc else Document()\n--&gt; 561 model = panel(obj, **kwargs).get_root(doc=doc)\n    562 widget = BokehModel(model, combine_events=True)\n    563 if hasattr(widget, '_view_count'):\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/base.py:514, in Pane.get_root(self, doc, comm, preprocess)\n    512         root = wrapper.get_root(doc, comm, preprocess)\n    513 else:\n--&gt; 514     root_view, root = self._get_root_model(doc, comm, preprocess)\n    515 ref = root.ref['id']\n    516 state._views[ref] = (root_view, root, doc, comm)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/base.py:455, in Pane._get_root_model(self, doc, comm, preprocess)\n    453     root_view = self\n    454 else:\n--&gt; 455     root = self.layout._get_model(doc, comm=comm)\n    456     root_view = self.layout\n    457 if preprocess:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/layout/base.py:183, in Panel._get_model(self, doc, root, parent, comm)\n    181 root = root or model\n    182 self._models[root.ref['id']] = (model, parent)\n--&gt; 183 objects, _ = self._get_objects(model, [], doc, root, comm)\n    184 props = self._get_properties(doc)\n    185 props[self._property_mapping['objects']] = objects\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/layout/base.py:165, in Panel._get_objects(self, model, old_objects, doc, root, comm)\n    163 else:\n    164     try:\n--&gt; 165         child = pane._get_model(doc, root, model, comm)\n    166     except RerenderError as e:\n    167         if e.layout is not None and e.layout is not self:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/holoviews.py:438, in HoloViews._get_model(self, doc, root, parent, comm)\n    436     plot = self.object\n    437 else:\n--&gt; 438     plot = self._render(doc, comm, root)\n    440 plot.pane = self\n    441 backend = plot.renderer.backend\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/holoviews.py:532, in HoloViews._render(self, doc, comm, root)\n    529     if comm:\n    530         kwargs['comm'] = comm\n--&gt; 532 return renderer.get_plot(self.object, **kwargs)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/bokeh/renderer.py:68, in BokehRenderer.get_plot(self_or_cls, obj, doc, renderer, **kwargs)\n     61 @bothmethod\n     62 def get_plot(self_or_cls, obj, doc=None, renderer=None, **kwargs):\n     63     \"\"\"\n     64     Given a HoloViews Viewable return a corresponding plot instance.\n     65     Allows supplying a document attach the plot to, useful when\n     66     combining the bokeh model with another plot.\n     67     \"\"\"\n---&gt; 68     plot = super().get_plot(obj, doc, renderer, **kwargs)\n     69     if plot.document is None:\n     70         plot.document = Document() if self_or_cls.notebook_context else curdoc()\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:234, in Renderer.get_plot(self_or_cls, obj, doc, renderer, comm, **kwargs)\n    232 if isinstance(obj, AdjointLayout):\n    233     obj = Layout(obj)\n--&gt; 234 plot = self_or_cls.plotting_class(obj)(obj, renderer=renderer,\n    235                                        **plot_opts)\n    236 defaults = [kd.default for kd in plot.dimensions]\n    237 init_key = tuple(v if d is None else d for v, d in\n    238                  zip(plot.keys[0], defaults))\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/bokeh/plot.py:734, in LayoutPlot.__init__(self, layout, keys, **params)\n    732 def __init__(self, layout, keys=None, **params):\n    733     super().__init__(layout, keys=keys, **params)\n--&gt; 734     self.layout, self.subplots, self.paths = self._init_layout(layout)\n    735     if self.top_level:\n    736         self.traverse(lambda x: attach_streams(self, x.hmap, 2),\n    737                       [GenericElementPlot])\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/bokeh/plot.py:787, in LayoutPlot._init_layout(self, layout)\n    785     layout_count += 1\n    786 num = 0 if empty else layout_count\n--&gt; 787 subplots, adjoint_layout = self._create_subplots(\n    788     view, positions, layout_dimensions, frame_ranges, num=num\n    789 )\n    791 # Generate the AdjointLayoutsPlot which will coordinate\n    792 # plotting of AdjointLayouts in the larger grid\n    793 plotopts = self.lookup_options(view, 'plot').options\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/bokeh/plot.py:818, in LayoutPlot._create_subplots(self, layout, positions, layout_dimensions, ranges, num)\n    816     continue\n    817 if not displayable(element):\n--&gt; 818     element = collate(element)\n    820 subplot_opts = dict(adjoined=main_plot)\n    821 # Options common for any subplot\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/util.py:78, in collate(obj)\n     76     if obj.type in [DynamicMap, HoloMap]:\n     77         obj_name = obj.type.__name__\n---&gt; 78         raise Exception(f\"Nesting a {obj_name} inside a DynamicMap is not \"\n     79                         \"supported. Ensure that the DynamicMap callback \"\n     80                         \"returns an Element or (Nd)Overlay. If you have \"\n     81                         \"applied an operation ensure it is not dynamic by \"\n     82                         \"setting dynamic=False.\")\n     83     return obj.collate()\n     84 if isinstance(obj, HoloMap):\n\nException: Nesting a DynamicMap inside a DynamicMap is not supported. Ensure that the DynamicMap callback returns an Element or (Nd)Overlay. If you have applied an operation ensure it is not dynamic by setting dynamic=False.\n\n\n\n:AdjointLayout\n   :DynamicMap   [time]\n      :Image   [x,y]   (sig0)\n   :DynamicMap   []\n      :DynamicMap   [time]\n         :Histogram   [sig0]   (Frequency)\n\n\n\n# this one works open file again if it seems to not work\n\nimport holoviews as hv\nimport hvplot.xarray\nimport numpy as np\nfrom holoviews import opts\nfrom holoviews.streams import RangeXY\n\nhv.extension('bokeh')\n\ntime = np.arange(8)\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\nrangexy = RangeXY()\n\ndef load_image(time, x_range, y_range):\n\n    hv_ds = hv.Dataset(fs.sig0.isel(time=time))\n    img = hv_ds.to(hv.Image, [\"x\", \"y\"])\n\n    if x_range and y_range:\n        img = img.select(x=x_range, y=y_range)\n\n    return hv.Image(img).opts(\n        cmap=\"viridis\", colorbar=True,frame_width=600,\n        tools=[\"hover\"], clim=(robust_min, robust_max), aspect=\"equal\")\n\n\n\nfinished_img = hv.DynamicMap(\n    load_image, \n    kdims=['time'], \n    streams=[rangexy]\n).redim.values(time=time).hist(normed=True)\n\nfinished_img \n\n\n# rangexy approach https://holoviews.org/reference/streams/bokeh/RangeXY.html\n\nimport holoviews as hv\nimport holoviews.operation as hvop\nhv.extension('bokeh')\n\n# xarray to holoviews dataset\nhv_ds = hv.Dataset(fs.sig0)\n\nimg = hv_ds.to(hv.Image, [\"x\", \"y\"], groupby=\"time\")\nimg.opts(aspect=\"equal\", cmap=\"viridis\", colorbar=True, height=400, tools=[\"hover\"])\n\ndef selected_hist(x_range, y_range, time):\n\n    obj = img[time].select(x=x_range, y=y_range) if x_range and y_range else img[time]\n    \n    return hvop.histogram(obj)\n\nrangexy = hv.streams.RangeXY(source=img)\ntime_stream = hv.streams.Stream.define('Time', time=0)()\n\n#img &lt;&lt; hv.DynamicMap(selected_hist, streams=[rangexy])\nhv.DynamicMap(selected_hist, streams=[rangexy, time_stream]) &lt;&lt; img\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:129, in option_state(element)\n    128 try:\n--&gt; 129     yield\n    130 except Exception:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:258, in display(obj, raw_output, **kwargs)\n    257     with option_state(obj):\n--&gt; 258         output = layout_display(obj)\n    259 elif isinstance(obj, (HoloMap, DynamicMap)):\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:149, in display_hook.&lt;locals&gt;.wrapped(element)\n    148 max_frames = OutputSettings.options['max_frames']\n--&gt; 149 mimebundle = fn(element, max_frames=max_frames)\n    150 if mimebundle is None:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:223, in layout_display(layout, max_frames)\n    221     return None\n--&gt; 223 return render(layout)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:76, in render(obj, **kwargs)\n     74     renderer = renderer.instance(fig='png')\n---&gt; 76 return renderer.components(obj, **kwargs)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:397, in Renderer.components(self, obj, fmt, comm, **kwargs)\n    396     return self._render_panel(plot, embed, comm)\n--&gt; 397 return self._render_ipywidget(plot)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:419, in Renderer._render_ipywidget(self, plot)\n    417 def _render_ipywidget(self, plot):\n    418     # Handle rendering object as ipywidget\n--&gt; 419     widget = ipywidget(plot, combine_events=True)\n    420     if hasattr(widget, '_repr_mimebundle_'):\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/io/notebook.py:561, in ipywidget(obj, doc, **kwargs)\n    560 doc = doc if doc else Document()\n--&gt; 561 model = panel(obj, **kwargs).get_root(doc=doc)\n    562 widget = BokehModel(model, combine_events=True)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/base.py:514, in Pane.get_root(self, doc, comm, preprocess)\n    513 else:\n--&gt; 514     root_view, root = self._get_root_model(doc, comm, preprocess)\n    515 ref = root.ref['id']\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/base.py:455, in Pane._get_root_model(self, doc, comm, preprocess)\n    454 else:\n--&gt; 455     root = self.layout._get_model(doc, comm=comm)\n    456     root_view = self.layout\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/layout/base.py:183, in Panel._get_model(self, doc, root, parent, comm)\n    182 self._models[root.ref['id']] = (model, parent)\n--&gt; 183 objects, _ = self._get_objects(model, [], doc, root, comm)\n    184 props = self._get_properties(doc)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/layout/base.py:165, in Panel._get_objects(self, model, old_objects, doc, root, comm)\n    164 try:\n--&gt; 165     child = pane._get_model(doc, root, model, comm)\n    166 except RerenderError as e:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/holoviews.py:438, in HoloViews._get_model(self, doc, root, parent, comm)\n    437 else:\n--&gt; 438     plot = self._render(doc, comm, root)\n    440 plot.pane = self\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/panel/pane/holoviews.py:532, in HoloViews._render(self, doc, comm, root)\n    530         kwargs['comm'] = comm\n--&gt; 532 return renderer.get_plot(self.object, **kwargs)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/bokeh/renderer.py:68, in BokehRenderer.get_plot(self_or_cls, obj, doc, renderer, **kwargs)\n     63 \"\"\"\n     64 Given a HoloViews Viewable return a corresponding plot instance.\n     65 Allows supplying a document attach the plot to, useful when\n     66 combining the bokeh model with another plot.\n     67 \"\"\"\n---&gt; 68 plot = super().get_plot(obj, doc, renderer, **kwargs)\n     69 if plot.document is None:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/renderer.py:216, in Renderer.get_plot(self_or_cls, obj, doc, renderer, comm, **kwargs)\n    215 # Initialize DynamicMaps with first data item\n--&gt; 216 initialize_dynamic(obj)\n    218 if not renderer:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/plotting/util.py:270, in initialize_dynamic(obj)\n    269 if not len(dmap):\n--&gt; 270     dmap[dmap._initial_key()]\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/spaces.py:1216, in DynamicMap.__getitem__(self, key)\n   1215 if cache is not None: return cache\n-&gt; 1216 val = self._execute_callback(*tuple_key)\n   1217 if data_slice:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/spaces.py:983, in DynamicMap._execute_callback(self, *args)\n    982 with dynamicmap_memoization(self.callback, self.streams):\n--&gt; 983     retval = self.callback(*args, **kwargs)\n    984 return self._style(retval)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/spaces.py:581, in Callable.__call__(self, *args, **kwargs)\n    580 try:\n--&gt; 581     ret = self.callable(*args, **kwargs)\n    582 except KeyError:\n    583     # KeyError is caught separately because it is used to signal\n    584     # invalid keys on DynamicMap and should not warn\n\nCell In[25], line 15, in selected_hist(x_range, y_range, time)\n     13 def selected_hist(x_range, y_range, time):\n---&gt; 15     obj = img[time].select(x=x_range, y=y_range) if x_range and y_range else img[time]\n     17     return hvop.histogram(obj)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/ndmapping.py:626, in NdMapping.__getitem__(self, indexslice)\n    624 if all(not (isinstance(el, (slice, set, list, tuple)) or callable(el))\n    625        for el in map_slice):\n--&gt; 626     return self._dataslice(self.data[map_slice], data_slice)\n    627 else:\n\nKeyError: (0,)\n\nDuring handling of the above exception, another exception occurred:\n\nKeyError                                  Traceback (most recent call last)\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/IPython/core/formatters.py:977, in MimeBundleFormatter.__call__(self, obj, include, exclude)\n    974     method = get_real_method(obj, self.print_method)\n    976     if method is not None:\n--&gt; 977         return method(include=include, exclude=exclude)\n    978     return None\n    979 else:\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/dimension.py:1275, in Dimensioned._repr_mimebundle_(self, include, exclude)\n   1268 def _repr_mimebundle_(self, include=None, exclude=None):\n   1269     \"\"\"\n   1270     Resolves the class hierarchy for the class rendering the\n   1271     object using any display hooks registered on Store.display\n   1272     hooks.  The output of all registered display_hooks is then\n   1273     combined and returned.\n   1274     \"\"\"\n-&gt; 1275     return Store.render(self)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/options.py:1428, in Store.render(cls, obj)\n   1426 data, metadata = {}, {}\n   1427 for hook in hooks:\n-&gt; 1428     ret = hook(obj)\n   1429     if ret is None:\n   1430         continue\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:287, in pprint_display(obj)\n    285 if not ip.display_formatter.formatters['text/plain'].pprint:\n    286     return None\n--&gt; 287 return display(obj, raw_output=True)\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:257, in display(obj, raw_output, **kwargs)\n    255         output = element_display(obj)\n    256 elif isinstance(obj, (Layout, NdLayout, AdjointLayout)):\n--&gt; 257     with option_state(obj):\n    258         output = layout_display(obj)\n    259 elif isinstance(obj, (HoloMap, DynamicMap)):\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/contextlib.py:153, in _GeneratorContextManager.__exit__(self, typ, value, traceback)\n    151     value = typ()\n    152 try:\n--&gt; 153     self.gen.throw(typ, value, traceback)\n    154 except StopIteration as exc:\n    155     # Suppress StopIteration *unless* it's the same exception that\n    156     # was passed to throw().  This prevents a StopIteration\n    157     # raised inside the \"with\" statement from being suppressed.\n    158     return exc is not value\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:131, in option_state(element)\n    129     yield\n    130 except Exception:\n--&gt; 131     dynamic_optstate(element, state=optstate)\n    132     raise\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/ipython/display_hooks.py:121, in dynamic_optstate(element, state)\n    118 def dynamic_optstate(element, state=None):\n    119     # Temporary fix to avoid issues with DynamicMap traversal\n    120     DynamicMap._deep_indexable = False\n--&gt; 121     optstate = StoreOptions.state(element,state=state)\n    122     DynamicMap._deep_indexable = True\n    123     return optstate\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/options.py:1754, in StoreOptions.state(cls, obj, state)\n   1752 current_custom_keys = set(Store.custom_options().keys())\n   1753 for key in current_custom_keys.difference(original_custom_keys):\n-&gt; 1754     del Store.custom_options()[key]\n   1755     cls.restore_ids(obj, ids)\n\nKeyError: 48\n\n\n\n:AdjointLayout\n   :DynamicMap\n   :HoloMap   [time]\n      :Image   [x,y]   (sig0)\n\n\n\nimport holoviews as hv\nimport holoviews.operation as hvop\nhv.extension('bokeh')\n\nhv_ds = hv.Dataset(fs.sig0)\n\ndef dynamic_image(time):\n    return hv_ds.to(hv.Image, [\"x\", \"y\"], groupby=\"time\")[time].opts(aspect=\"equal\", cmap=\"viridis\", colorbar=True, height=400, tools=[\"hover\"])\n\n# Function to create the histogram\ndef selected_hist(x_range, y_range, time):\n    img = dynamic_image(time)\n    obj = img.select(x=x_range, y=y_range) if x_range and y_range else img\n    return hvop.histogram(obj)\n\n# Streams for interaction\nrangexy = hv.streams.RangeXY(source=dynamic_image(0))\ntime_stream = hv.streams.Stream.define('Time', time=0)()\n\n# DynamicMap for the image and histogram\ndynamic_img = hv.DynamicMap(dynamic_image, streams=[time_stream])\ndynamic_hist = hv.DynamicMap(selected_hist, streams=[rangexy, time_stream])\n\n# Overlay the image and histogram\nlayout = dynamic_img + dynamic_hist\nlayout.opts(merge_tools=False)\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n  \n  \n\n\n\n\n\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[26], line 17\n     14     return hvop.histogram(obj)\n     16 # Streams for interaction\n---&gt; 17 rangexy = hv.streams.RangeXY(source=dynamic_image(0))\n     18 time_stream = hv.streams.Stream.define('Time', time=0)()\n     20 # DynamicMap for the image and histogram\n\nCell In[26], line 8, in dynamic_image(time)\n      7 def dynamic_image(time):\n----&gt; 8     return hv_ds.to(hv.Image, [\"x\", \"y\"], groupby=\"time\")[time].opts(aspect=\"equal\", cmap=\"viridis\", colorbar=True, height=400, tools=[\"hover\"])\n\nFile ~/miniconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/holoviews/core/ndmapping.py:626, in NdMapping.__getitem__(self, indexslice)\n    622 map_slice = self._expand_slice(map_slice)\n    624 if all(not (isinstance(el, (slice, set, list, tuple)) or callable(el))\n    625        for el in map_slice):\n--&gt; 626     return self._dataslice(self.data[map_slice], data_slice)\n    627 else:\n    628     conditions = self._generate_conditions(map_slice)\n\nKeyError: (0,)\n\n\n\n\nimport numpy as np\nimport holoviews as hv\nimport holoviews.operation as hvop\nimport panel as pn\n\n\nhv.extension('bokeh')\n\nrobust_min = fs.sig0.quantile(0.02).item()\nrobust_max = fs.sig0.quantile(0.98).item()\n\n\nimg = fs.sig0 .hvplot.image(x=\"x\", y=\"y\", groupby=\"time\", clim=(robust_min, robust_max), aspect=\"equal\", framewise=False).opts(\n        cmap=\"viridis\", colorbar=True,\n        tools=[\"hover\"])\n\ndef selected_hist(x_range, y_range, time, **kwargs):\n    obj = img.select(x=x_range, y=y_range).select(time=time) if x_range and y_range else dynamic_image(time)\n    return hvop.histogram(obj, num_bins=50, normed=True).opts(height=472, width=200)\n\ntime_slider = pn.widgets.IntSlider(value=0, start=0, end=len(fs.sig0.time) - 1, step=1, name='Time')\n\nrangexy = hv.streams.RangeXY(source=dynamic_image(0))\n\nimg &lt;&lt; hv.DynamicMap(selected_hist, streams=[rangexy, time_slider])\n\nhttps://holoviews.org/Reference_Manual/holoviews.operation.html"
  },
  {
    "objectID": "unit_02/old02_06_backscatter-variability.html",
    "href": "unit_02/old02_06_backscatter-variability.html",
    "title": "Load Sentinel-1 data",
    "section": "",
    "text": "import os\nimport xarray as xr\nimport rioxarray\nimport rasterio\nimport dask.array as da\nfrom glob import glob\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nimport folium\nimport matplotlib.patches as patches\nfrom datetime import datetime\nimport pandas as pd\nLoad Metadata to get some information on the data. We want to get the scale_factor of the data.\ndata_path = Path('~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler').expanduser() # SAT-1 data is inside the saocom_gamma folder but this could change\ntif_files = glob(f\"{data_path}/*.tif\")\n\nfor tif_path in tif_files:\n    print(f\"Metadata for file: {os.path.basename(tif_path)}\")\n    with rasterio.open(tif_path) as src:\n      tags = src.tags()\n      print(src.meta)\n      print(f\"Tags: {tags}\")\n      print(f\"Scalefactor: {tags.get('scale_factor')}\\n\")\n      #break\n    \n\nMetadata for file: D20230829_165123--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050093', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_073256.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230829T165123_20230829T165148_050093_060726_855E.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 07:32:57', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-29 16:51:23', 'time_end': '2023-08-29 16:51:48', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230910_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050268', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_4_A01_gmr_jobfile_A0105_log_20231201_080609.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230910T165124_20230910T165149_050268_060D16_BAC4.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 08:06:10', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-09-10 16:51:24', 'time_end': '2023-09-10 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230817_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '049918', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_065607.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230817T165122_20230817T165147_049918_060121_784A.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 06:56:08', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-17 16:51:22', 'time_end': '2023-08-17 16:51:47', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231028_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050968', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_13_A01_gmr_jobfile_A0105_log_20231201_020603.xml', 'orbit_aux_file': 'None', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231028T165124_20231028T165149_050968_062503_8D6A.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'False', 'processing_date': '2023-12-01 02:06:04', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-28 16:51:24', 'time_end': '2023-10-28 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231016_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050793', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_14_A01_gmr_jobfile_A0105_log_20231201_051314.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231016T165124_20231016T165149_050793_061F17_EF2F.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 05:13:15', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-16 16:51:24', 'time_end': '2023-10-16 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230922_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050443', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_7_A01_gmr_jobfile_A0105_log_20231201_082733.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230922T165124_20230922T165149_050443_06130C_7915.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 08:27:33', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-09-22 16:51:24', 'time_end': '2023-09-22 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20231004_165124--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '050618', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_13_A01_gmr_jobfile_A0105_log_20231201_035056.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20231004T165124_20231004T165149_050618_06190F_38E7.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 03:50:57', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-10-04 16:51:24', 'time_end': '2023-10-04 16:51:49', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\n\nMetadata for file: D20230805_165122--_GMR------_S1AIWGRDH1VVA_146_A0105_EU010M_E052N015T1.tif\n{'driver': 'GTiff', 'dtype': 'int16', 'nodata': -9999.0, 'width': 10000, 'height': 10000, 'count': 1, 'crs': CRS.from_epsg(27704), 'transform': Affine(10.0, 0.0, 5200000.0,\n       0.0, -10.0, 1600000.0)}\nTags: {'abs_orbit_number': '049743', 'band_1': 'Gamma0_VV', 'border_noise_removed': 'True', 'creator': 'TUWGEO', 'distanceuom': 'm', 'distancevalue': '10', 'equi7_tile': 'EU010M_E052N015T1', 'ext_dem': '/eodc/private/tuwgeo/users/acube/data/input/acube_dem_eh.tif', 'grid': 'Equi7 Grid', 'gtc_applied': 'True', 'log_file': 'tasklist_2_A01_gmr_jobfile_A0105_log_20231201_034630.xml', 'orbit_aux_file': 'POE', 'parent_data_file': 'S1A_IW_GRDH_1SDV_20230805T165122_20230805T165147_049743_05FB3C_64DB.zip', 'polarisation': 'VV', 'precise_orbit_applied': 'True', 'processing_date': '2023-12-01 03:46:31', 'processing_software': 'SGRT', 'processing_software_version': 'A0105-2.4.9.post.dev6.pre', 'rel_orbit_number': '146', 'rtf_applied': 'True', 'sat_product_id': 'S1AIWGRDH1VVA', 'scale_factor': '100.0', 'thermal_noise_removed': 'True', 'time_begin': '2023-08-05 16:51:22', 'time_end': '2023-08-05 16:51:47', 'variable_name': 'GMR', 'AREA_OR_POINT': 'Area'}\nScalefactor: 100.0\nAs we can see frome here the data was captured 8 images between the 5th August 2023 and the 28th October 2023. The image contains Gamma VV values.\nNow we can load the data and and apply preprocessing. From the Metaddata we could extract a scalingfactor of 100 which we now need to apply.\nWe get a xarray.DataSet and convert it to an xarray.DataArray because we only have one variable, the VV backscatter.\nWe have 8 timestemps. For performance reasons we will fous on only on one time becasue the data does not change to much over time.\n(Using DataArray is slower than DataSet)\nWe downsample already in the preprocessing because we do not need all the resolution because we are working with the corine data map and the resolution there is 100 by 100 meters. When we downsample x and y coordinates by 10 we get pixles of size 100 by 100meters which fits perfectly to the\ndef _preprocess(x):  \n    scale_factor = pd.to_numeric(\n        rasterio.open(x.encoding[\"source\"]).tags().get('scale_factor')\n    )\n\n    time_value = pd.to_datetime(\n        rasterio.open(x.encoding[\"source\"]).tags().get('time_begin')\n    )\n\n    x = x / scale_factor\n\n    x = x.assign_coords(time=time_value).expand_dims(\"time\")\n\n    return x.squeeze(\"band\").drop_vars(\"band\")\n\nds = xr.open_mfdataset(\n    '~/shared/datasets/rs/datapool/mrs/saocom_gamma/S1gammaNeusiedler/*.tif',\n    engine=\"rasterio\",\n    combine='nested',\n    concat_dim=\"time\",\n    preprocess=_preprocess\n)\n\nds = ds[list(ds.data_vars.keys())[0]] .isel(time=1)\nds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 10000, x: 10000)&gt; Size: 800MB\ndask.array&lt;getitem, shape=(10000, 10000), dtype=float64, chunksize=(1, 10000), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 80kB 5.2e+06 5.2e+06 5.2e+06 ... 5.3e+06 5.3e+06\n  * y            (y) float64 80kB 1.6e+06 1.6e+06 1.6e+06 ... 1.5e+06 1.5e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 10000x: 10000dask.array&lt;chunksize=(1, 10000), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n762.94 MiB\n78.12 kiB\n\n\nShape\n(10000, 10000)\n(1, 10000)\n\n\nDask graph\n10000 chunks in 42 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           10000 10000\n\n\n\n\nCoordinates: (4)x(x)float645.2e+06 5.2e+06 ... 5.3e+06 5.3e+06array([5200005., 5200015., 5200025., ..., 5299975., 5299985., 5299995.])y(y)float641.6e+06 1.6e+06 ... 1.5e+06 1.5e+06array([1599995., 1599985., 1599975., ..., 1500025., 1500015., 1500005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5200005.0, 5200015.0, 5200025.0, 5200035.0, 5200045.0, 5200055.0,\n       5200065.0, 5200075.0, 5200085.0, 5200095.0,\n       ...\n       5299905.0, 5299915.0, 5299925.0, 5299935.0, 5299945.0, 5299955.0,\n       5299965.0, 5299975.0, 5299985.0, 5299995.0],\n      dtype='float64', name='x', length=10000))yPandasIndexPandasIndex(Index([1599995.0, 1599985.0, 1599975.0, 1599965.0, 1599955.0, 1599945.0,\n       1599935.0, 1599925.0, 1599915.0, 1599905.0,\n       ...\n       1500095.0, 1500085.0, 1500075.0, 1500065.0, 1500055.0, 1500045.0,\n       1500035.0, 1500025.0, 1500015.0, 1500005.0],\n      dtype='float64', name='y', length=10000))Attributes: (0)\nds_downscaled = ds.coarsen(x=10, y=10, boundary='pad').mean()\nds_downscaled\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 1000, x: 1000)&gt; Size: 8MB\ndask.array&lt;mean_agg-aggregate, shape=(1000, 1000), dtype=float64, chunksize=(1, 1000), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 8kB 5.2e+06 5.2e+06 5.2e+06 ... 5.3e+06 5.3e+06\n  * y            (y) float64 8kB 1.6e+06 1.6e+06 1.6e+06 ... 1.5e+06 1.5e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 1000x: 1000dask.array&lt;chunksize=(1, 1000), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n7.63 MiB\n7.81 kiB\n\n\nShape\n(1000, 1000)\n(1, 1000)\n\n\nDask graph\n1000 chunks in 48 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           1000 1000\n\n\n\n\nCoordinates: (4)x(x)float645.2e+06 5.2e+06 ... 5.3e+06 5.3e+06array([5200050., 5200150., 5200250., ..., 5299750., 5299850., 5299950.])y(y)float641.6e+06 1.6e+06 ... 1.5e+06 1.5e+06array([1599950., 1599850., 1599750., ..., 1500250., 1500150., 1500050.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5200050.0, 5200150.0, 5200250.0, 5200350.0, 5200450.0, 5200550.0,\n       5200650.0, 5200750.0, 5200850.0, 5200950.0,\n       ...\n       5299050.0, 5299150.0, 5299250.0, 5299350.0, 5299450.0, 5299550.0,\n       5299650.0, 5299750.0, 5299850.0, 5299950.0],\n      dtype='float64', name='x', length=1000))yPandasIndexPandasIndex(Index([1599950.0, 1599850.0, 1599750.0, 1599650.0, 1599550.0, 1599450.0,\n       1599350.0, 1599250.0, 1599150.0, 1599050.0,\n       ...\n       1500950.0, 1500850.0, 1500750.0, 1500650.0, 1500550.0, 1500450.0,\n       1500350.0, 1500250.0, 1500150.0, 1500050.0],\n      dtype='float64', name='y', length=1000))Attributes: (0)\nTo get an idea of the region we are looking at we want to display it. Therefore we combine 100 pixles to a single one using the mean to get faster printing performance.\nimg = ds_downscaled\n\nareas = [\n    {'name': 'area1', 'x_min': 5.21e+06, 'x_max': 5.22e+06, 'y_min': 1.56e+06, 'y_max': 1.57e+06},\n    {'name': 'area2', 'x_min': 5.285e+06, 'x_max': 5.295e+06, 'y_min': 1.56e+06, 'y_max': 1.57e+06}\n    ]\n\nfig, ax = plt.subplots(figsize=(15, 10))\n\nimg.plot(ax=ax, robust=True)\n\nfor area in areas:\n    rect = patches.Rectangle(\n        (area['x_min'], area['y_min']),\n        area['x_max'] - area['x_min'],\n        area['y_max'] - area['y_min'],\n        linewidth=2,\n        edgecolor='red',\n        facecolor='none'\n    )\n    ax.add_patch(rect)\nax.set_aspect('equal')\n\nplt.show()\nWe will now focus on a smaller red region to make the runtime faster. We combing the time dimensions by using the mean.\narea_downscaled_dataarrays = {}\n\nfor area in areas:\n    roi = ds_downscaled.sel(\n        x=slice(area['x_min'], area['x_max']),\n        y=slice(area['y_max'], area['y_min'])\n    )    \n    area_downscaled_dataarrays[area['name']] = roi\n\n# Extract individual DataArrays for each area\nds_downscaled_area1 = area_downscaled_dataarrays['area1']\nds_downscaled_area2 = area_downscaled_dataarrays['area2']\nds_downscaled_area2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 100, x: 100)&gt; Size: 80kB\ndask.array&lt;getitem, shape=(100, 100), dtype=float64, chunksize=(1, 100), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 800B 5.285e+06 5.285e+06 ... 5.295e+06 5.295e+06\n  * y            (y) float64 800B 1.57e+06 1.57e+06 ... 1.56e+06 1.56e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 100x: 100dask.array&lt;chunksize=(1, 100), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n78.12 kiB\n800 B\n\n\nShape\n(100, 100)\n(1, 100)\n\n\nDask graph\n100 chunks in 49 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           100 100\n\n\n\n\nCoordinates: (4)x(x)float645.285e+06 5.285e+06 ... 5.295e+06array([5285050., 5285150., 5285250., 5285350., 5285450., 5285550., 5285650.,\n       5285750., 5285850., 5285950., 5286050., 5286150., 5286250., 5286350.,\n       5286450., 5286550., 5286650., 5286750., 5286850., 5286950., 5287050.,\n       5287150., 5287250., 5287350., 5287450., 5287550., 5287650., 5287750.,\n       5287850., 5287950., 5288050., 5288150., 5288250., 5288350., 5288450.,\n       5288550., 5288650., 5288750., 5288850., 5288950., 5289050., 5289150.,\n       5289250., 5289350., 5289450., 5289550., 5289650., 5289750., 5289850.,\n       5289950., 5290050., 5290150., 5290250., 5290350., 5290450., 5290550.,\n       5290650., 5290750., 5290850., 5290950., 5291050., 5291150., 5291250.,\n       5291350., 5291450., 5291550., 5291650., 5291750., 5291850., 5291950.,\n       5292050., 5292150., 5292250., 5292350., 5292450., 5292550., 5292650.,\n       5292750., 5292850., 5292950., 5293050., 5293150., 5293250., 5293350.,\n       5293450., 5293550., 5293650., 5293750., 5293850., 5293950., 5294050.,\n       5294150., 5294250., 5294350., 5294450., 5294550., 5294650., 5294750.,\n       5294850., 5294950.])y(y)float641.57e+06 1.57e+06 ... 1.56e+06array([1569950., 1569850., 1569750., 1569650., 1569550., 1569450., 1569350.,\n       1569250., 1569150., 1569050., 1568950., 1568850., 1568750., 1568650.,\n       1568550., 1568450., 1568350., 1568250., 1568150., 1568050., 1567950.,\n       1567850., 1567750., 1567650., 1567550., 1567450., 1567350., 1567250.,\n       1567150., 1567050., 1566950., 1566850., 1566750., 1566650., 1566550.,\n       1566450., 1566350., 1566250., 1566150., 1566050., 1565950., 1565850.,\n       1565750., 1565650., 1565550., 1565450., 1565350., 1565250., 1565150.,\n       1565050., 1564950., 1564850., 1564750., 1564650., 1564550., 1564450.,\n       1564350., 1564250., 1564150., 1564050., 1563950., 1563850., 1563750.,\n       1563650., 1563550., 1563450., 1563350., 1563250., 1563150., 1563050.,\n       1562950., 1562850., 1562750., 1562650., 1562550., 1562450., 1562350.,\n       1562250., 1562150., 1562050., 1561950., 1561850., 1561750., 1561650.,\n       1561550., 1561450., 1561350., 1561250., 1561150., 1561050., 1560950.,\n       1560850., 1560750., 1560650., 1560550., 1560450., 1560350., 1560250.,\n       1560150., 1560050.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5285050.0, 5285150.0, 5285250.0, 5285350.0, 5285450.0, 5285550.0,\n       5285650.0, 5285750.0, 5285850.0, 5285950.0, 5286050.0, 5286150.0,\n       5286250.0, 5286350.0, 5286450.0, 5286550.0, 5286650.0, 5286750.0,\n       5286850.0, 5286950.0, 5287050.0, 5287150.0, 5287250.0, 5287350.0,\n       5287450.0, 5287550.0, 5287650.0, 5287750.0, 5287850.0, 5287950.0,\n       5288050.0, 5288150.0, 5288250.0, 5288350.0, 5288450.0, 5288550.0,\n       5288650.0, 5288750.0, 5288850.0, 5288950.0, 5289050.0, 5289150.0,\n       5289250.0, 5289350.0, 5289450.0, 5289550.0, 5289650.0, 5289750.0,\n       5289850.0, 5289950.0, 5290050.0, 5290150.0, 5290250.0, 5290350.0,\n       5290450.0, 5290550.0, 5290650.0, 5290750.0, 5290850.0, 5290950.0,\n       5291050.0, 5291150.0, 5291250.0, 5291350.0, 5291450.0, 5291550.0,\n       5291650.0, 5291750.0, 5291850.0, 5291950.0, 5292050.0, 5292150.0,\n       5292250.0, 5292350.0, 5292450.0, 5292550.0, 5292650.0, 5292750.0,\n       5292850.0, 5292950.0, 5293050.0, 5293150.0, 5293250.0, 5293350.0,\n       5293450.0, 5293550.0, 5293650.0, 5293750.0, 5293850.0, 5293950.0,\n       5294050.0, 5294150.0, 5294250.0, 5294350.0, 5294450.0, 5294550.0,\n       5294650.0, 5294750.0, 5294850.0, 5294950.0],\n      dtype='float64', name='x'))yPandasIndexPandasIndex(Index([1569950.0, 1569850.0, 1569750.0, 1569650.0, 1569550.0, 1569450.0,\n       1569350.0, 1569250.0, 1569150.0, 1569050.0, 1568950.0, 1568850.0,\n       1568750.0, 1568650.0, 1568550.0, 1568450.0, 1568350.0, 1568250.0,\n       1568150.0, 1568050.0, 1567950.0, 1567850.0, 1567750.0, 1567650.0,\n       1567550.0, 1567450.0, 1567350.0, 1567250.0, 1567150.0, 1567050.0,\n       1566950.0, 1566850.0, 1566750.0, 1566650.0, 1566550.0, 1566450.0,\n       1566350.0, 1566250.0, 1566150.0, 1566050.0, 1565950.0, 1565850.0,\n       1565750.0, 1565650.0, 1565550.0, 1565450.0, 1565350.0, 1565250.0,\n       1565150.0, 1565050.0, 1564950.0, 1564850.0, 1564750.0, 1564650.0,\n       1564550.0, 1564450.0, 1564350.0, 1564250.0, 1564150.0, 1564050.0,\n       1563950.0, 1563850.0, 1563750.0, 1563650.0, 1563550.0, 1563450.0,\n       1563350.0, 1563250.0, 1563150.0, 1563050.0, 1562950.0, 1562850.0,\n       1562750.0, 1562650.0, 1562550.0, 1562450.0, 1562350.0, 1562250.0,\n       1562150.0, 1562050.0, 1561950.0, 1561850.0, 1561750.0, 1561650.0,\n       1561550.0, 1561450.0, 1561350.0, 1561250.0, 1561150.0, 1561050.0,\n       1560950.0, 1560850.0, 1560750.0, 1560650.0, 1560550.0, 1560450.0,\n       1560350.0, 1560250.0, 1560150.0, 1560050.0],\n      dtype='float64', name='y'))Attributes: (0)\narea_dataarrays = {}\n\nfor area in areas:\n    roi = ds.sel(\n        x=slice(area['x_min'], area['x_max']),\n        y=slice(area['y_max'], area['y_min'])\n    )    \n    area_dataarrays[area['name']] = roi\n\n# Extract individual DataArrays for each area\nds_area1 = area_dataarrays['area1']\nds_area2 = area_dataarrays['area2']\nds_area2\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 1000, x: 1000)&gt; Size: 8MB\ndask.array&lt;getitem, shape=(1000, 1000), dtype=float64, chunksize=(1, 1000), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 8kB 5.285e+06 5.285e+06 ... 5.295e+06 5.295e+06\n  * y            (y) float64 8kB 1.57e+06 1.57e+06 ... 1.56e+06 1.56e+06\n    spatial_ref  int64 8B 0\n    time         datetime64[ns] 8B 2023-08-17T16:51:22xarray.DataArray'band_data'y: 1000x: 1000dask.array&lt;chunksize=(1, 1000), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n7.63 MiB\n7.81 kiB\n\n\nShape\n(1000, 1000)\n(1, 1000)\n\n\nDask graph\n1000 chunks in 43 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                           1000 1000\n\n\n\n\nCoordinates: (4)x(x)float645.285e+06 5.285e+06 ... 5.295e+06array([5285005., 5285015., 5285025., ..., 5294975., 5294985., 5294995.])y(y)float641.57e+06 1.57e+06 ... 1.56e+06array([1569995., 1569985., 1569975., ..., 1560025., 1560015., 1560005.])spatial_ref()int640crs_wkt :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984projected_crs_name :Azimuthal_Equidistantgrid_mapping_name :azimuthal_equidistantlatitude_of_projection_origin :53.0longitude_of_projection_origin :24.0false_easting :5837287.81977false_northing :2121415.69617spatial_ref :PROJCS[\"Azimuthal_Equidistant\",GEOGCS[\"WGS 84\",DATUM[\"WGS_1984\",SPHEROID[\"WGS 84\",6378137,298.257223563,AUTHORITY[\"EPSG\",\"7030\"]],AUTHORITY[\"EPSG\",\"6326\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Azimuthal_Equidistant\"],PARAMETER[\"latitude_of_center\",53],PARAMETER[\"longitude_of_center\",24],PARAMETER[\"false_easting\",5837287.81977],PARAMETER[\"false_northing\",2121415.69617],UNIT[\"metre\",1,AUTHORITY[\"EPSG\",\"9001\"]],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH]]GeoTransform :5200000.0 10.0 0.0 1600000.0 0.0 -10.0array(0)time()datetime64[ns]2023-08-17T16:51:22array('2023-08-17T16:51:22.000000000', dtype='datetime64[ns]')Indexes: (2)xPandasIndexPandasIndex(Index([5285005.0, 5285015.0, 5285025.0, 5285035.0, 5285045.0, 5285055.0,\n       5285065.0, 5285075.0, 5285085.0, 5285095.0,\n       ...\n       5294905.0, 5294915.0, 5294925.0, 5294935.0, 5294945.0, 5294955.0,\n       5294965.0, 5294975.0, 5294985.0, 5294995.0],\n      dtype='float64', name='x', length=1000))yPandasIndexPandasIndex(Index([1569995.0, 1569985.0, 1569975.0, 1569965.0, 1569955.0, 1569945.0,\n       1569935.0, 1569925.0, 1569915.0, 1569905.0,\n       ...\n       1560095.0, 1560085.0, 1560075.0, 1560065.0, 1560055.0, 1560045.0,\n       1560035.0, 1560025.0, 1560015.0, 1560005.0],\n      dtype='float64', name='y', length=1000))Attributes: (0)\nfig, ax  = plt.subplots(1,2, figsize=(20,8))\n\nds_downscaled_area2.plot(ax=ax[0], robust=True)\nds_area2.plot(ax=ax[1], robust=True)\nplt.show()"
  },
  {
    "objectID": "unit_02/old02_06_backscatter-variability.html#load-corine-land-cover",
    "href": "unit_02/old02_06_backscatter-variability.html#load-corine-land-cover",
    "title": "Load Sentinel-1 data",
    "section": "Load Corine Land cover",
    "text": "Load Corine Land cover\n\nimport rasterio\nfrom pathlib import Path\n\ntif_path = Path('~/shared/datasets/rs/datapool/mrs/Corine_Land_Cover_2018.tif').expanduser()\n\nwith rasterio.open(tif_path) as src:\n    meta = src.meta\n    tags = src.tags()\n\nprint(f\"Metadata for file: {tif_path.name}\")\nprint(\"Metadata:\")\nprint(meta)\nprint(\"\\nTags:\")\nprint(tags)\n\nMetadata for file: Corine_Land_Cover_2018.tif\nMetadata:\n{'driver': 'GTiff', 'dtype': 'int8', 'nodata': -128.0, 'width': 65000, 'height': 46000, 'count': 1, 'crs': CRS.from_wkt('PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]'), 'transform': Affine(100.0, 0.0, 900000.0,\n       0.0, -100.0, 5500000.0)}\n\nTags:\n{'DataType': 'Thematic', 'AREA_OR_POINT': 'Area'}\n\n\n\nds_corine = xr.open_mfdataset(\n    '~/shared/datasets/rs/datapool/mrs/Corine_Land_Cover_2018.tif',\n    engine=\"rasterio\",\n    combine='nested',\n    concat_dim=\"time\"\n)\nds_corine = ds_corine[list(ds_corine.data_vars)[0]]\nds_corine = ds_corine.squeeze('time', drop=True).squeeze('band', drop=True)\n\nds_corine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (y: 46000, x: 65000)&gt; Size: 12GB\ndask.array&lt;getitem, shape=(46000, 65000), dtype=float32, chunksize=(128, 128), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 520kB 9e+05 9.002e+05 9.002e+05 ... 7.4e+06 7.4e+06\n  * y            (y) float64 368kB 5.5e+06 5.5e+06 5.5e+06 ... 9.002e+05 9e+05\n    spatial_ref  int64 8B ...\nAttributes:\n    DataType:                Thematic\n    AREA_OR_POINT:           Area\n    RepresentationType:      THEMATIC\n    STATISTICS_COVARIANCES:  136.429646247598\n    STATISTICS_MAXIMUM:      48\n    STATISTICS_MEAN:         25.753373398066\n    STATISTICS_MINIMUM:      1\n    STATISTICS_SKIPFACTORX:  1\n    STATISTICS_SKIPFACTORY:  1\n    STATISTICS_STDDEV:       11.680310194836xarray.DataArray'band_data'y: 46000x: 65000dask.array&lt;chunksize=(128, 128), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n11.14 GiB\n64.00 kiB\n\n\nShape\n(46000, 65000)\n(128, 128)\n\n\nDask graph\n182880 chunks in 5 graph layers\n\n\nData type\nfloat32 numpy.ndarray\n\n\n\n\n                                             65000 46000\n\n\n\n\nCoordinates: (3)x(x)float649e+05 9.002e+05 ... 7.4e+06 7.4e+06array([ 900050.,  900150.,  900250., ..., 7399750., 7399850., 7399950.])y(y)float645.5e+06 5.5e+06 ... 9.002e+05 9e+05array([5499950., 5499850., 5499750., ...,  900250.,  900150.,  900050.])spatial_ref()int64...crs_wkt :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101004reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989projected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0spatial_ref :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]GeoTransform :900000.0 100.0 0.0 5500000.0 0.0 -100.0[1 values with dtype=int64]Indexes: (2)xPandasIndexPandasIndex(Index([ 900050.0,  900150.0,  900250.0,  900350.0,  900450.0,  900550.0,\n        900650.0,  900750.0,  900850.0,  900950.0,\n       ...\n       7399050.0, 7399150.0, 7399250.0, 7399350.0, 7399450.0, 7399550.0,\n       7399650.0, 7399750.0, 7399850.0, 7399950.0],\n      dtype='float64', name='x', length=65000))yPandasIndexPandasIndex(Index([5499950.0, 5499850.0, 5499750.0, 5499650.0, 5499550.0, 5499450.0,\n       5499350.0, 5499250.0, 5499150.0, 5499050.0,\n       ...\n        900950.0,  900850.0,  900750.0,  900650.0,  900550.0,  900450.0,\n        900350.0,  900250.0,  900150.0,  900050.0],\n      dtype='float64', name='y', length=46000))Attributes: (10)DataType :ThematicAREA_OR_POINT :AreaRepresentationType :THEMATICSTATISTICS_COVARIANCES :136.429646247598STATISTICS_MAXIMUM :48STATISTICS_MEAN :25.753373398066STATISTICS_MINIMUM :1STATISTICS_SKIPFACTORX :1STATISTICS_SKIPFACTORY :1STATISTICS_STDDEV :11.680310194836\n\n\n\nprint(ds_corine.isel(x=slice(30000, 300001), y=slice(20000, 20001)).values)\n\n[[nan nan nan ... nan nan nan]]\n\n\n\nPlot all in low resolution\n\nds_corine_downscaled = ds_corine.coarsen(x=1000, y=1000, boundary='pad').mean()\nds_corine_downscaled = ds_corine_downscaled.chunk({\"x\": 100, \"y\": 100})\nds_corine_downscaled\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&lt;xarray.DataArray 'band_data' (time: 1, y: 46, x: 65)&gt; Size: 24kB\ndask.array&lt;rechunk-merge, shape=(1, 46, 65), dtype=float64, chunksize=(1, 46, 65), chunktype=numpy.ndarray&gt;\nCoordinates:\n  * x            (x) float64 520B 9.5e+05 1.05e+06 ... 7.25e+06 7.35e+06\n  * y            (y) float64 368B 5.45e+06 5.35e+06 ... 1.05e+06 9.5e+05\n    spatial_ref  int64 8B ...\n  * time         (time) object 8B Nonexarray.DataArray'band_data'time: 1y: 46x: 65dask.array&lt;chunksize=(1, 46, 65), meta=np.ndarray&gt;\n\n\n\n\n\n\n\n\n\n\n\nArray\nChunk\n\n\n\n\nBytes\n23.36 kiB\n23.36 kiB\n\n\nShape\n(1, 46, 65)\n(1, 46, 65)\n\n\nDask graph\n1 chunks in 12 graph layers\n\n\nData type\nfloat64 numpy.ndarray\n\n\n\n\n                         65 46 1\n\n\n\n\nCoordinates: (4)x(x)float649.5e+05 1.05e+06 ... 7.35e+06array([ 950000., 1050000., 1150000., 1250000., 1350000., 1450000., 1550000.,\n       1650000., 1750000., 1850000., 1950000., 2050000., 2150000., 2250000.,\n       2350000., 2450000., 2550000., 2650000., 2750000., 2850000., 2950000.,\n       3050000., 3150000., 3250000., 3350000., 3450000., 3550000., 3650000.,\n       3750000., 3850000., 3950000., 4050000., 4150000., 4250000., 4350000.,\n       4450000., 4550000., 4650000., 4750000., 4850000., 4950000., 5050000.,\n       5150000., 5250000., 5350000., 5450000., 5550000., 5650000., 5750000.,\n       5850000., 5950000., 6050000., 6150000., 6250000., 6350000., 6450000.,\n       6550000., 6650000., 6750000., 6850000., 6950000., 7050000., 7150000.,\n       7250000., 7350000.])y(y)float645.45e+06 5.35e+06 ... 9.5e+05array([5450000., 5350000., 5250000., 5150000., 5050000., 4950000., 4850000.,\n       4750000., 4650000., 4550000., 4450000., 4350000., 4250000., 4150000.,\n       4050000., 3950000., 3850000., 3750000., 3650000., 3550000., 3450000.,\n       3350000., 3250000., 3150000., 3050000., 2950000., 2850000., 2750000.,\n       2650000., 2550000., 2450000., 2350000., 2250000., 2150000., 2050000.,\n       1950000., 1850000., 1750000., 1650000., 1550000., 1450000., 1350000.,\n       1250000., 1150000., 1050000.,  950000.])spatial_ref()int64...crs_wkt :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]semi_major_axis :6378137.0semi_minor_axis :6356752.314140356inverse_flattening :298.257222101004reference_ellipsoid_name :GRS 1980longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :ETRS89horizontal_datum_name :European Terrestrial Reference System 1989projected_crs_name :ETRS89-extended / LAEA Europegrid_mapping_name :lambert_azimuthal_equal_arealatitude_of_projection_origin :52.0longitude_of_projection_origin :10.0false_easting :4321000.0false_northing :3210000.0spatial_ref :PROJCS[\"ETRS89-extended / LAEA Europe\",GEOGCS[\"ETRS89\",DATUM[\"European_Terrestrial_Reference_System_1989\",SPHEROID[\"GRS 1980\",6378137,298.257222101004,AUTHORITY[\"EPSG\",\"7019\"]],AUTHORITY[\"EPSG\",\"6258\"]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4258\"]],PROJECTION[\"Lambert_Azimuthal_Equal_Area\"],PARAMETER[\"latitude_of_center\",52],PARAMETER[\"longitude_of_center\",10],PARAMETER[\"false_easting\",4321000],PARAMETER[\"false_northing\",3210000],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"3035\"]]GeoTransform :900000.0 100.0 0.0 5500000.0 0.0 -100.0[1 values with dtype=int64]time(time)objectNonearray([None], dtype=object)Indexes: (3)xPandasIndexPandasIndex(Index([ 950000.0, 1050000.0, 1150000.0, 1250000.0, 1350000.0, 1450000.0,\n       1550000.0, 1650000.0, 1750000.0, 1850000.0, 1950000.0, 2050000.0,\n       2150000.0, 2250000.0, 2350000.0, 2450000.0, 2550000.0, 2650000.0,\n       2750000.0, 2850000.0, 2950000.0, 3050000.0, 3150000.0, 3250000.0,\n       3350000.0, 3450000.0, 3550000.0, 3650000.0, 3750000.0, 3850000.0,\n       3950000.0, 4050000.0, 4150000.0, 4250000.0, 4350000.0, 4450000.0,\n       4550000.0, 4650000.0, 4750000.0, 4850000.0, 4950000.0, 5050000.0,\n       5150000.0, 5250000.0, 5350000.0, 5450000.0, 5550000.0, 5650000.0,\n       5750000.0, 5850000.0, 5950000.0, 6050000.0, 6150000.0, 6250000.0,\n       6350000.0, 6450000.0, 6550000.0, 6650000.0, 6750000.0, 6850000.0,\n       6950000.0, 7050000.0, 7150000.0, 7250000.0, 7350000.0],\n      dtype='float64', name='x'))yPandasIndexPandasIndex(Index([5450000.0, 5350000.0, 5250000.0, 5150000.0, 5050000.0, 4950000.0,\n       4850000.0, 4750000.0, 4650000.0, 4550000.0, 4450000.0, 4350000.0,\n       4250000.0, 4150000.0, 4050000.0, 3950000.0, 3850000.0, 3750000.0,\n       3650000.0, 3550000.0, 3450000.0, 3350000.0, 3250000.0, 3150000.0,\n       3050000.0, 2950000.0, 2850000.0, 2750000.0, 2650000.0, 2550000.0,\n       2450000.0, 2350000.0, 2250000.0, 2150000.0, 2050000.0, 1950000.0,\n       1850000.0, 1750000.0, 1650000.0, 1550000.0, 1450000.0, 1350000.0,\n       1250000.0, 1150000.0, 1050000.0,  950000.0],\n      dtype='float64', name='y'))timePandasIndexPandasIndex(Index([None], dtype='object', name='time'))Attributes: (0)\n\n\n\n\nTransform the areas to the different coordinate system\n\nfrom pyproj import Transformer\n\n# Define the coordinate systems\ntransformer = Transformer.from_crs(\"EPSG:27704\", \"EPSG:3035\", always_xy=True)\n\n# Convert each area\nconverted_areas = []\nfor area in areas:\n    x_min, y_min = transformer.transform(area['x_min'], area['y_min'])\n    x_max, y_max = transformer.transform(area['x_max'], area['y_max'])\n    converted_areas.append({\n        'name': area['name'],\n        'x_min': x_min,\n        'x_max': x_max,\n        'y_min': y_min,\n        'y_max': y_max\n    })\n\n# Print converted areas\nfor area in converted_areas:\n    print(f\"Converted {area['name']}:\")\n    print(f\"  x_min: {area['x_min']}\")\n    print(f\"  x_max: {area['x_max']}\")\n    print(f\"  y_min: {area['y_min']}\")\n    print(f\"  y_max: {area['y_max']}\")\n\nConverted area1:\n  x_min: 4745274.896573421\n  x_max: 4753248.745192058\n  y_min: 2740445.239774567\n  y_max: 2752143.0474406034\nConverted area2:\n  x_min: 4818856.960410232\n  x_max: 4826829.115803347\n  y_min: 2754607.1683874787\n  y_max: 2766310.2777903196\n\n\n\narea_corine_dataarrays = {}\n\nfor area in converted_areas:\n    roi = ds_corine.sel(\n        x=slice(area['x_min'], area['x_max']),\n        y=slice(area['y_max'], area['y_min'])\n    )    \n    area_corine_dataarrays[area['name']] = roi\n\nds_corine_area1 = area_corine_dataarrays['area1']\nds_corine_area2 = area_corine_dataarrays['area2']\n\nds_corine_area2.plot()\n\n\n\n\n\n\n\n\n\nfig, ax  = plt.subplots(1,3, figsize=(24,7))\n\nds_downscaled_area2.plot(ax=ax[0], robust=True)\nds_area2.plot(ax=ax[1], robust=True)\nds_corine_area2.plot(ax=ax[2])\nplt.show()"
  },
  {
    "objectID": "unit_02/old02_06_backscatter-variability.html#plotting-a-histogram",
    "href": "unit_02/old02_06_backscatter-variability.html#plotting-a-histogram",
    "title": "Load Sentinel-1 data",
    "section": "Plotting a histogram",
    "text": "Plotting a histogram"
  },
  {
    "objectID": "unit_02/old02_06_backscatter-variability.html#plotting-in-the-epsg27704",
    "href": "unit_02/old02_06_backscatter-variability.html#plotting-in-the-epsg27704",
    "title": "Load Sentinel-1 data",
    "section": "Plotting in the EPSG:27704",
    "text": "Plotting in the EPSG:27704\nIn the EPSG:27704 coordinate system (plotting is quite slow):\n\nds_downsampled = ds.isel().coarsen(x=10, y=10, boundary='pad').mean()\n\n\ndata_vars = list(ds.data_vars)\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Plot each variable (image) in the dataset\nfor var in data_vars:\n    img = ds_downsampled[var]\n    img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n\nplt.show()"
  },
  {
    "objectID": "unit_02/old02_06_backscatter-variability.html#get-the-overlapping-area",
    "href": "unit_02/old02_06_backscatter-variability.html#get-the-overlapping-area",
    "title": "Load Sentinel-1 data",
    "section": "Get the overlapping area",
    "text": "Get the overlapping area\n\ndata_vars = list(ds_WGS84.data_vars)\n\nds_overlapping = ds_WGS84[data_vars[0]]  # Start with the first variable\n\nfor var in data_vars[1:]:\n    next_image = ds_WGS84[var]\n    ds_overlapping = ds_overlapping.rio.clip_box(*next_image.rio.bounds())\n\nTo reduce the runtime we downsample the data to make the plotting faster.\n\nds_downsampled = ds_WGS84.isel().coarsen(x=10, y=10, boundary='pad').mean()\nds_overlapping_downsampled = ds_overlapping.isel().coarsen(x=10, y=10, boundary='pad').mean()\n\n\nds_downsampled[data_vars[0]].plot()\n\n\nds_overlapping_downsampled.plot()\n\nWe transform our Data to the EPSG:4326 coordinate system which uses Latitude and Longitude values.\n\nds_WGS84 = ds.rio.reproject(\"EPSG:4326\")\nds_WGS84\n\n\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Plot each variable (image) in the dataset\nfor var in data_vars:\n    img = ds_downsampled[var]\n    img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n\n# Highlight the overlapping area with a colored box\nminx, miny, maxx, maxy = ds_overlapping_downsampled.rio.bounds()\n\n# Add a colored box for the overlapping area\nrect = plt.Rectangle((minx, miny), maxx - minx, maxy - miny, fill=False, edgecolor='red', linewidth=2)\nax.add_patch(rect)\n\n# Set labels and titles\nax.set_title(\"Overlapping Area of Satellite Images\")\nax.set_xlabel(\"Longitude\")\nax.set_ylabel(\"Latitude\")\n\nplt.show()\n\n\n---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\nCell In[22], line 6\n      4 for var in data_vars:\n      5     img = ds_downsampled[var]\n----&gt; 6     img.plot(ax=ax, add_colorbar=False, cmap='gray', alpha=0.03)  # Adjust alpha for transparency\n      8 # Highlight the overlapping area with a colored box\n      9 minx, miny, maxx, maxy = ds_overlapping_downsampled.rio.bounds()\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/plot/accessor.py:48, in DataArrayPlotAccessor.__call__(self, **kwargs)\n     46 @functools.wraps(dataarray_plot.plot, assigned=(\"__doc__\", \"__annotations__\"))\n     47 def __call__(self, **kwargs) -&gt; Any:\n---&gt; 48     return dataarray_plot.plot(self._da, **kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/plot/dataarray_plot.py:270, in plot(darray, row, col, col_wrap, ax, hue, subplot_kws, **kwargs)\n    219 def plot(\n    220     darray: DataArray,\n    221     *,\n   (...)\n    228     **kwargs: Any,\n    229 ) -&gt; Any:\n    230     \"\"\"\n    231     Default plot of DataArray using :py:mod:`matplotlib:matplotlib.pyplot`.\n    232 \n   (...)\n    266     xarray.DataArray.squeeze\n    267     \"\"\"\n    268     darray = darray.squeeze(\n    269         d for d, s in darray.sizes.items() if s == 1 and d not in (row, col, hue)\n--&gt; 270     ).compute()\n    272     plot_dims = set(darray.dims)\n    273     plot_dims.discard(row)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataarray.py:1194, in DataArray.compute(self, **kwargs)\n   1169 \"\"\"Manually trigger loading of this array's data from disk or a\n   1170 remote source into memory and return a new array.\n   1171 \n   (...)\n   1191 dask.compute\n   1192 \"\"\"\n   1193 new = self.copy(deep=False)\n-&gt; 1194 return new.load(**kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataarray.py:1162, in DataArray.load(self, **kwargs)\n   1142 def load(self, **kwargs) -&gt; Self:\n   1143     \"\"\"Manually trigger loading of this array's data from disk or a\n   1144     remote source into memory and return this array.\n   1145 \n   (...)\n   1160     dask.compute\n   1161     \"\"\"\n-&gt; 1162     ds = self._to_temp_dataset().load(**kwargs)\n   1163     new = self._from_temp_dataset(ds)\n   1164     self._variable = new._variable\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/core/dataset.py:865, in Dataset.load(self, **kwargs)\n    862 chunkmanager = get_chunked_array_type(*lazy_data.values())\n    864 # evaluate all the chunked arrays simultaneously\n--&gt; 865 evaluated_data: tuple[np.ndarray[Any, Any], ...] = chunkmanager.compute(\n    866     *lazy_data.values(), **kwargs\n    867 )\n    869 for k, data in zip(lazy_data, evaluated_data):\n    870     self.variables[k].data = data\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/xarray/namedarray/daskmanager.py:86, in DaskManager.compute(self, *data, **kwargs)\n     81 def compute(\n     82     self, *data: Any, **kwargs: Any\n     83 ) -&gt; tuple[np.ndarray[Any, _DType_co], ...]:\n     84     from dask.array import compute\n---&gt; 86     return compute(*data, **kwargs)\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/site-packages/dask/base.py:664, in compute(traverse, optimize_graph, scheduler, get, *args, **kwargs)\n    661     postcomputes.append(x.__dask_postcompute__())\n    663 with shorten_traceback():\n--&gt; 664     results = schedule(dsk, keys, **kwargs)\n    666 return repack([f(r, *a) for r, (f, a) in zip(results, postcomputes)])\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/queue.py:171, in Queue.get(self, block, timeout)\n    169 elif timeout is None:\n    170     while not self._qsize():\n--&gt; 171         self.not_empty.wait()\n    172 elif timeout &lt; 0:\n    173     raise ValueError(\"'timeout' must be a non-negative number\")\n\nFile /opt/anaconda3/envs/06_backscatter-variability/lib/python3.10/threading.py:320, in Condition.wait(self, timeout)\n    318 try:    # restore state no matter what (e.g., KeyboardInterrupt)\n    319     if timeout is None:\n--&gt; 320         waiter.acquire()\n    321         gotit = True\n    322     else:\n\nKeyboardInterrupt: \n\n\n\n\n\n\n\n\n\n\n\nds_downsampled = ds_WGS84.isel().coarsen(x=100, y=100, boundary='pad').mean()\n\nds_downsampled.plot.scatter()\n\n#plt.figure(figsize=(12, 8))\n#downsampled_data.plot(cmap='viridis')\n#plt.title('Resampled Data Slice at Time = 0')\n#plt.show()"
  }
]